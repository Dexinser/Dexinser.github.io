<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl">
  
  
  
  
  <title>To die or not to die, this is a question~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="分享Web前端开发，自我提升，前端工程师必备技能使用方法等的原创或者转载文章~">
<meta property="og:type" content="website">
<meta property="og:title" content="To die or not to die, this is a question~">
<meta property="og:url" content="https://dexinser.github.io/page/4/index.html">
<meta property="og:site_name" content="To die or not to die, this is a question~">
<meta property="og:description" content="分享Web前端开发，自我提升，前端工程师必备技能使用方法等的原创或者转载文章~">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="To die or not to die, this is a question~">
<meta name="twitter:description" content="分享Web前端开发，自我提升，前端工程师必备技能使用方法等的原创或者转载文章~">
  
    <link rel="alternative" href="/atom.xml" title="To die or not to die, this is a question~" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet">
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Dexinser</a></h1>
        </hgroup>
        
        <p class="header-subtitle">不想成为架构师的程序员不是一个好的程序员~</p>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/categories/开发工具/">玩转开发工具</a></li>
                        
                            <li><a  href="/categories/digital">玩转数码</a></li>
                        
                            <li><a  href="/categories/algorithm">算法学习</a></li>
                        
                            <li><a  href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="/xxxxx" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/CSS3/" style="font-size: 17.5px;">CSS3</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/TV/" style="font-size: 10px;">TV</a> <a href="/tags/book/" style="font-size: 12.5px;">book</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/others/" style="font-size: 10px;">others</a> <a href="/tags/个人分享/" style="font-size: 15px;">个人分享</a> <a href="/tags/个人感悟/" style="font-size: 12.5px;">个人感悟</a> <a href="/tags/个人日记/" style="font-size: 12.5px;">个人日记</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/历史故事/" style="font-size: 10px;">历史故事</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/商业问题/" style="font-size: 10px;">商业问题</a> <a href="/tags/学习笔记/" style="font-size: 12.5px;">学习笔记</a> <a href="/tags/影视人生/" style="font-size: 12.5px;">影视人生</a> <a href="/tags/影评/" style="font-size: 10px;">影评</a> <a href="/tags/思维能力/" style="font-size: 10px;">思维能力</a> <a href="/tags/杂/" style="font-size: 10px;">杂</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/笔试/" style="font-size: 10px;">笔试</a> <a href="/tags/计算机基础/" style="font-size: 10px;">计算机基础</a> <a href="/tags/计算机系统/" style="font-size: 10px;">计算机系统</a> <a href="/tags/认知提升/" style="font-size: 17.5px;">认知提升</a> <a href="/tags/诗与远方/" style="font-size: 10px;">诗与远方</a> <a href="/tags/资源分享/" style="font-size: 10px;">资源分享</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/maocg_web">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">爱动漫,爱游戏,爱编程,爱运动,爱的太多了!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Dexinser</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Dexinser</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不想成为架构师的程序员不是一个好的程序员~</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/categories/开发工具/">玩转开发工具</a></li>
                
                    <li><a href="/categories/digital">玩转数码</a></li>
                
                    <li><a href="/categories/algorithm">算法学习</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="/xxxxx" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-2017/11/Math.floor()方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/11/Math.floor()方法.html" class="article-date">
      <time datetime="2022-11-05T14:53:17.301Z" itemprop="datePublished">2022-11-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2017/11/Math.floor()方法.html">Math.floor()等方法的用法</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Math-floor-方法的深层解析"><a href="#Math-floor-方法的深层解析" class="headerlink" title="Math.floor()方法的深层解析"></a>Math.floor()方法的深层解析</h2><p>  大家都知道这是一个JavaScript的基础的方法—向下取整，但是你们有没有遇到过这个方法不听话呢？哈哈，接下来就让我们来领教一下这个方法什么时候才会出现不听话吧！<br>  <code>!function test(){
            var is = 100;
            window.setInterval(function(){
                is = is/7;
                Math.floor(is);
                console.log(is)
            },10)
        }()</code><br>        这个方法之后的结果为14.124235…<br>这段代码中就用到了Math.floor()这个方法，但是这个方法就在这个时候不听话了，is这个变量居然一直取到了小数点后好多好多位。这是为什么呢？其实并不是这个方法不好用了，只是我们把这个方法用错了而已，因为is这个变量是一个Number类型的数字，是一个原始值（栈类型）不可改变。所以上面的代码我们访问的其实还是原来的is的值，并没有访问Math.floor()之后的is值。<br>我们可以这样访问到Math.floor()之后的is值。代码如下：<br><code>!function test(){
            var is = 100;
            window.setInterval(function(){
                is = is/7;
                console.log(Math.floor(is);)
            },10)
        }()</code><br>这样之后的结果就是14了。<br>通过这篇文章，只是想告诉你，JavaScript语言的一些值的类型，有引用值和原始值，引用值也就是堆数据类型的值，原始值在JavaScript语言中有undefined、Number、Boolean、String等，并且不同的值类型之间的不同的区别是什么，尤其重要的是千万不要试图去改变原始值，因为你真的拗不过他们的！哈哈，好了，就这样了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/基础方法分享/">基础方法分享</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-2017/11/DOM" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/11/DOM.html" class="article-date">
      <time datetime="2022-11-05T14:53:17.296Z" itemprop="datePublished">2022-11-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2017/11/DOM.html">浏览器之DOM</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong> 浏览器之DOM：</strong> <excerpt in index | 首页摘要></excerpt></p>
<h2 id="DOM—-gt-Document-Object-Model"><a href="#DOM—-gt-Document-Object-Model" class="headerlink" title="DOM—&gt;Document Object Model"></a>DOM—&gt;Document Object Model</h2><p>DOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。<br>DOM不能操作CSS！！！DOM修改CSS的是通过改变HTML间接改变CSS的。改变不了CSS行间样式，改变的是HTML。</p>
<p>DOM之后一些成组出现的东西都是类数组的形式。</p>
<p>每一个词条就是一个query。每个query都是人工自己写的。因为商家都追求不平凡，要和别家的有区分，绚丽一点儿的。</p>
<p><code>var div = document.getElementsByTagName(&#39;div&#39;)[0];
div.style.width = &quot;100px&quot;;
div.style.height = &quot;100px&quot;;
div.style.backgroundColor = &quot;red&quot;;
在div上永久绑定一个方法，每次点击都变色。
var count = 0;
div.onclick = function () {
  count ++;
  if(count % 2 == 1) {
    this.style.background = &quot;green&quot;;
  }else{
    this.style.background = &quot;red&quot;;
  }
}</code></p>
<p>鼠标监控：<br><code>document.onkeydown = function(e) {
  switch(e.which) {
    case 37:
      div.style.left = perseInt(div.style.left) - speed + &#39;px&#39;;
    case 38:
      div.style.top = perseInt(div.style.top) + speed + &#39;px&#39;;
    case 39:
      div.style.left = perseInt(div.style.left) + speed + &#39;px&#39;;
    case 40:
      div.style.top = perseInt(div.style.top) - speed + &#39;px&#39;;
  }
}</code></p>
<h2 id="对节点的增删改查"><a href="#对节点的增删改查" class="headerlink" title="对节点的增删改查"></a>对节点的增删改查</h2><p>查<br>查看元素节点<br>document代表整个文档<br>document.getElementById() //元素id 在Ie8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素<br>.getElementsByTagName() // 标签名<br>getElementByName(); //，需注意，只有部分标签name可生效（表单，表单元素，img，iframe）<br>.getElementsByClassName() // 类名 -&gt; ie8和ie8以下的ie版本中没有，可以多个class一起<br>.querySelector() // css选择器   在ie7和ie7以下的版本中没有<br>.querySelectorAll() // css选择器 在ie7和ie7以下的版本中没有<br>但是他和querySelector这两个方法不常用，因为这两个方法不是实时的，静态的。因为js语言就是实时的，后期只要操作HTML就会重新执行一下页面，所以效率低，但是执行的是实时的。</p>
<h2 id="DOM结构树-–-gt-一系列继承关系。"><a href="#DOM结构树-–-gt-一系列继承关系。" class="headerlink" title="DOM结构树  –&gt; 一系列继承关系。"></a>DOM结构树  –&gt; 一系列继承关系。</h2><p>Node也是一个构造函数，他是最顶头的那个函数对象。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span>   就是<span class="selector-tag">HTMLDocument</span></span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span>    就是<span class="selector-tag">Document</span></span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span>   就是<span class="selector-tag">Node</span></span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span>   就是<span class="selector-tag">EventTarget</span>   这是一个事件</span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span>   就是系统上的<span class="selector-tag">Object</span>的原型，最终都会追溯到系统上的__<span class="selector-tag">proto__</span></span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.documentElement</span>   代表的就是<span class="selector-tag">HTML</span>标签</span><br><span class="line"><span class="selector-tag">Document</span>  <span class="selector-tag">--</span>&gt; <span class="selector-tag">HTMLDocument</span>.</span><br><span class="line"><span class="selector-tag">document</span>代表的是整个页面文档。<span class="selector-tag">Document</span>原型链</span><br></pre></td></tr></table></figure></p>
<ol>
<li>getElementById方法定义在Document.prototype上，即Element节点上不能使用。</li>
<li>getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element)</li>
<li>getElementsByTagName方法定义在Document.prototype 和 Element.prototype上</li>
<li>HTMLDocument.prototype定义了一些常用的属性，body,head,分别指代HTML文档中的<body><head><meta name="generator" content="Hexo 3.9.0">标签。</head></body></li>
<li>Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代<html>元素</html></li>
<li>getElementsByClassName、querySelectorAll、querySelector在Document,Element类中均有定义</li>
</ol>
<p><code>&lt;div&gt;&lt;span&gt;1&lt;/span&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;</code><br><code>var div = document.getElementsByTagName(&#39;div&#39;)[0];</code><br><code>var span = div.getElementsByTagName(&#39;span&#39;)[0];</code><br>在开发的时候也是先选中父级，然后在父级下选择要选择的子级。</p>
<h2 id="节点的类型"><a href="#节点的类型" class="headerlink" title="节点的类型"></a>节点的类型</h2><p>元素节点   —— 1<br>属性节点   —— 2<br>文本节点   —— 3<br>注释节点   —— 8<br>document  —— 9<br>DocumentFragment  ——  11 （文档碎片节点）<br>获取节点类型   nodeType </p>
<h2 id="遍历节点树："><a href="#遍历节点树：" class="headerlink" title="遍历节点树："></a>遍历节点树：</h2><p> parentNode -&gt; 父节点  每个节点只有一个父节点(最顶端的parentNode为#document。再往上就是null);<br> childNodes -&gt; 子节点们<br> firstChild -&gt; 第一个子节点<br> lastChild -&gt; 最后一个子节点<br> nextSibling-&gt;后一个兄弟元素<br> previousSibling-&gt;前一个兄弟元素</p>
<p>所说的IE不兼容说的都是IE9以下的。IE10以上都兼容W3C标准了。<br>基于元素节点树的遍历<br>parentElement -&gt; 返回当前元素的父元素节点 (IE不兼容)<br>children -&gt; 只返回当前元素的元素子节点<br>node.childElementCount  === node.children.length当前元素节点的子元素节点个数(IE不兼容)<br>firstElementChild -&gt; 返回的是第一个元素节点(IE不兼容)<br>lastElementChild -&gt; 返回的是最后一个元素节点(IE不兼容)<br>nextElementSibling / previousElementSibling -&gt;返回后一个/前一个兄弟元素节点（IE不兼容)</p>
<h2 id="节点的四个属性"><a href="#节点的四个属性" class="headerlink" title="节点的四个属性"></a>节点的四个属性</h2><p>nodeName<br>元素的标签名，以大写形式表示,只读<br>nodeValue<br>Text节点或Comment节点的文本内容,可读写<br>nodeType（必须记住，很重要的！）<br>该节点的类型，只读<br>attributes<br>Element 节点的属性集合,比如：<div id="only" class="demo"></div>  div.attributes取出来一个集合放到一个类数组里面。 可以改变值div.attributes[0].value = ‘abc’; 能赋值能改值，只能改属性值，也就是更改id的值。</p>
<p>节点的一个方法  Node.hasChildNodes();   有没有子节点，返回结果是false或者true。</p>
<h2 id="DOM基本操作："><a href="#DOM基本操作：" class="headerlink" title="DOM基本操作："></a>DOM基本操作：</h2><p>增<br><code>document.createElement();
document.createTextNode();
document.createComment();
document.createDocumentFragment();</code><br>插<br><code>PARENTNODE.appendChild();
PARENTNODE.insertBefore(a, b);</code><br>例如：页面中有<code>&lt;div&gt;</code><br><code>&lt;span&gt;&lt;/span&gt;</code><br><code>&lt;/div&gt;</code><br><code>var str = document.createElement(&#39;strong&#39;);</code><br><code>var div = document.getElementsByTagName(&#39;div&#39;)[0];</code><br><code>div.insertBefore(str, span)</code><br>就是把创建的strong标签插入到div里面的span之前。</p>
<p>删除标签<br><code>div.removeChild();</code>   其实是剪切,先找到要删除的标签的父级，然后用的是父级删除其中子级的标签功能，一般都用的是这个，因为想用的时候，如果还保存着就还可以找到。真正的删除是用对象<code>.remove();</code>   这是新出的方法，原先没有的。这个是真正的删除了，就再也找不到了。</p>
<p>替换标签也是父级调用，<code>parentNode.replaceChild(new, origin);</code>用新的去替换久的。被替换的标签不是被删除了，而是被剪切出来了。</p>
<p><code>div.appendChild(p)</code>,在div标签中加上一些内容或者标签等等。</p>
<h2 id="Element节点的一些属性"><a href="#Element节点的一些属性" class="headerlink" title="Element节点的一些属性"></a>Element节点的一些属性</h2><p><code>innerHTML</code>  这个可以获取标签中的内容。不是追加，是可以覆盖原先的内容的，但是可以用+=的方法追加内容。还可以改变CSS样式的，只要写入就能使用。<br><code>innerText(火狐不兼容) / textContent(老版本IE不好使)</code>   可取可赋值。但是这个方法一定要慎重的去用。因为会把原先的内容给覆盖的。</p>
<h2 id="Element节点的一些方法"><a href="#Element节点的一些方法" class="headerlink" title="Element节点的一些方法"></a>Element节点的一些方法</h2><p><code>ele.setAttribute();</code> 设置原生DOM上的属性 例如：<br><code>div.setArrtibute(&#39;id&#39;,&#39;only&#39;)</code>   这表示在div上加上id属性。还可以加上一些没有的属性，也就是人为加上去的属性。就比如在标签上人为设置一个属性，data-log=’0’; 这个认为加上的属性是用来计算数据量的，算流量的，看这些流量从哪些网站分流出来的，计算给钱。   取data-log值就是：  <code>div.getAttribute(&#39;data-log&#39;);</code></p>
<p><code>ele.getAttribute();</code> 取原生DOM上的属性<br><code>div.getArrtibute();</code>取出行间属性的值。</p>
<h2 id="日期对象Date"><a href="#日期对象Date" class="headerlink" title="日期对象Date();"></a>日期对象Date();</h2><p>先  <code>var date = new Date();</code><br>然后就能调用Date()方法的一些方法。<br><code>date.getDate();</code> 从Data对象中返回一个月中的某一天 （1-31）  <code>date.getDay();</code>   从Data对象返回一周中的某一天（0-6）<br><code>date.getMonth();</code> 从Data对象返回月份（0-11）<br><code>date.getFullYear();</code>  从Data对象以四位数字返回年份（后来才有的方法）<br><code>date.getYear();</code>  请使用<code>data.getFullYear()</code>方法：一开始就有的方法。只不过这个方法有一个缺点，就是它是用六位表示年月日的。95.03.17；到二千年的时候就不够用了。所以才有了上面的那个完整表示的方法。这就是千年虫问题的出现。当然肯定还有万年虫，不过这个就不是我们需要考虑的问题了，离我们太遥远了~~<br><code>date.getHours();</code>   返回Data对象的小时（0-23）<br><code>date.getMinutes();</code>   返回Data对象的分钟（0-59）<br><code>date.getSeconds();</code>   返回Data对象的秒数（0-59）<br><code>date.getMillseconds();</code>  返回Data对象的毫秒数（0-999）<br><code>date.getTime();</code>    返回1970年1月1日至今的毫秒数（这个方法是最常用的，把耶稣出生的那一年当做人类的纪元年，计算机的纪元年就是1970.01.01，所有的计算机和手机的时间的计算都是根据计算机纪元时间来换算出来的。重点是：这个方法能帮我们算时间差，每个功能用的时间差就是根据这个方法来计算的）<br><code>date.getTimezoneOffset();</code>   返回本地时间与格林威治标准时间（GMT）的分钟差<br><code>date.getUTCDate();</code>    根据世界时从Data对象返回月中的一天（1-31）<br><code>date.getUTCDay();</code>   根据世界时从Data对象返回月份（0-6）<br><code>date.getUTCMonth();</code>  根据世界时从Data对象返回月份（0-11）<br><code>date.getUTCFullYear();</code> 根据世界时从Data对象返回四位数的年份<br><code>date.getUTCHours();</code>  根据世界时返回Data对象的小时（0-23）<br><code>date.getUTCMiutes();</code>  根据世界时返回Data对象的分钟（0-59）<br><code>date.getUTCSeconds();</code>  根据世界时返回Date对象的秒钟（0-59）<br><code>date.getUTCMillseconds();</code> 根据世界时返回Date对象的毫秒（0-999）<br><code>date.parse();</code>   返回1970年1月1日午夜到指定日期（字符串）的毫秒数<br>人为设置一个时间点，到设置好的时间点执行一个功能，比如淘宝上的定时抢购，就是到达人为设置的时间点之后立即执行函数功能。<br><code>date.setDate();</code>   设置Date对象中月的某一天（1-31）<br><code>date.setMonth();</code>   设置Date对象中月份（0-11）<br><code>date.setFullYear();</code>  设置Date对象中的年份（四位数字）<br><code>date.setYear();</code>     请使用setFullYear()方法代替<br><code>date.setHours();</code>    设置Date对象中的小时（0-23）<br><code>date.setMinutes();</code>  设置Date对象中的分钟（0-59）<br><code>date.setSeconds();</code>    设置Date对象中的秒钟（0-59）<br><code>date.setMillseconds();</code>  设置Date对象中的毫秒（0-999）<br><code>date.setTime();</code>      以毫秒设置Date对象<br><code>date.toSource();</code>    返回该对象的源代码<br><code>date.toString();</code>   把Date对象转换为字符串<br><code>date.toTimeString();</code>  把Date对象的时间部分转换为字符串<br><code>date.toDateString();</code>  把Date对象的日期部分转换成字符串</p>
<h1 id="JS定时器"><a href="#JS定时器" class="headerlink" title="JS定时器"></a>JS定时器</h1><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><p>   <code>setInterval(function() {}, time);</code>time只能赋一次值，并不能通过改变time的值来动态改变隔得时间。定时器并不准。如何看时间准不准呢？写一个函数如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> lastTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"> <span class="built_in">console</span>.log(lastTime - firstTime);</span><br><span class="line"> firstTime - lastTime;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>在控制台上打印的结果并不总是1000毫秒，所以这个方法的时间间隔并不是很准的。所以要是做的功能对时间有很精确的时间要求就不能寄希望于这个方法上的。与系统执行代码所消耗的时间还有。这个方法的排列机制是基于红黑数的。每一次这个方法都会返回一个唯一标示。应用就是VIP电影有试看时间，就是用这个方法。</p>
<p><code>setTimeout();</code>   只执行一次。<br><code>clearInterval();</code><br><code>clearTimeout();</code><br>全局对象window上的方法，内部函数this指向window<br>注意 ：<code>setInterval(&quot;func()&quot;,1000);</code></p>
<h2 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a>查看滚动条的滚动距离</h2><p><code>window.pageXOffset/pageYOffset</code><br>IE8及IE8以下不兼容<br>IE8及IE8以下用的下面这个方法：<br><code>document.body/documentElement.scrollLeft/scrollTop</code><br>但是这两个方法是在IE浏览器中到底哪个能用是不一定的，又但是这两个问题是互相冲突的，一个有值另一个就没有值了。所以就让两个值加起来用。<br>兼容性比较混乱，用时取两个值相加，因为不可能存在两个同时有值</p>
<h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><p><strong>封装兼容性方法，求滚动轮滚动距离</strong></p>
<p><code>getScrollOffset()</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollOffset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.pageXOffset) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">	x : <span class="built_in">window</span>.pageXOffset,</span><br><span class="line">	y : <span class="built_in">window</span>.pageYOffset</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">	x : <span class="built_in">document</span>.body.scrollLeft + <span class="built_in">document</span>.documentElement.scrollLeft,</span><br><span class="line">	y : <span class="built_in">document</span>.bodu.scrollTop + <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果放大页面的尺寸。那么返回的可视区窗口就是放大之后的可视区的实际尺寸。</p>
<p>就在编程的html标签的上面还有一个&lt;!DOCTYPE html&gt;表示 文档类型，当有这个标签的时候浏览器的渲染模式就是标准模式，没有这个标签的时候浏览器的渲染模式就是怪异模式。渲染就是识别语法并绘制成页面。<br>标准模式：正常的渲染模式。一般除了IE浏览器其他的浏览器的与之前的变动并不是很大，所以也用不着去启用怪异模式。<br>怪异模式又叫混杂模式：试图去兼容浏览器之前的版本。</p>
<p><strong>有一个方法能看当前浏览器是在什么渲染模式下：</strong><br><code>document.compatMode</code>     当返回值为：”CSS1Compat”;  表示标准模式下            当返回值为：”BackCompat”  表示在怪异模式下，向后兼容</p>
<h2 id="查看视口的尺寸的方法："><a href="#查看视口的尺寸的方法：" class="headerlink" title="查看视口的尺寸的方法："></a>查看视口的尺寸的方法：</h2><p><code>window.innerWidth/innerHeight</code><br>IE8及IE8以下不兼容<br>标准模式下，任意浏览器都兼容的方法：<br><code>document.documentElement.clientWidth/clientHeight</code><br>适用于怪异模式下的浏览器的方法：<br><code>document.body.clientWidth/clientHeight</code></p>
<h2 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h2><p><strong>封装兼容性方法，返回浏览器视口尺寸</strong><br><code>getViewportOffset()</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewportOffset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.innerWidth) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">	w : <span class="built_in">window</span>.innerWidth,</span><br><span class="line">	h : <span class="built_in">window</span>.innerHeight</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode === <span class="string">"BackCompat"</span>)&#123;     </span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">	  w : <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">	  h : <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode === <span class="string">"CSS1Compat"</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">	  w : <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">  	  h : <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="比较获取查看窗口尺寸的方法的取值差异："><a href="#比较获取查看窗口尺寸的方法的取值差异：" class="headerlink" title="比较获取查看窗口尺寸的方法的取值差异："></a>比较获取查看窗口尺寸的方法的取值差异：</h2><p>使用<code>$(window).width()</code>与 <code>$(window).height();</code><br>获取的是屏幕可视区域的宽高，不包括滚动条与工具条。<br><code>window.outerWidth</code> 与 <code>window.outerHeight;</code><br>获取的是加上工具条与滚动条窗口的宽高与高度(总高度算上全部滚动条的高度)。<br><code>window.innerWidth</code>与 <code>window.innerHeight;</code><br>获取的是可视区域的宽高，但是宽度包含了纵向滚动条的宽度。<br><code>document.documentElement.clientWidth</code>与 <code>document.documentElement.clientHeight;</code><br>获取的是屏幕可视区域的宽高，不包括滚动条与工具条，跟JQuery的获取的结果是一样的。<br><code>document.body.clientWidth</code> 与 <code>document.body.clientHeight;</code><br>获取的是宽度可视区域的宽度，获取的高度是是body内容的高度，如果内容只有200px，那么这个高度也是200px，如果想通过它得到屏幕可视区域的宽高，需要样式设置如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"> <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">div</span>, <span class="selector-tag">p</span>, <span class="selector-tag">ul</span> &#123;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="兼容性："><a href="#兼容性：" class="headerlink" title="兼容性："></a>兼容性：</h2><ol>
<li>window.innerWidth 和 window.outerWidth 属性方法IE8以及以下不支持，得到的值为undefined。</li>
<li>测试浏览器IE，火狐，谷歌，Safari都支持怪异下的方法属性<code>document.documentElement.clientWidth</code> 与 <code>document.documentElement.clientHeight</code>。</li>
</ol>
<p>结论：<br>获取屏幕的可视区域的宽高可使用jQuery的方式获得，也可以使用原生js获得，即：<code>document.documentElement.clientWidth</code>与 <code>document.documentElement.clientHeight</code> 方法。</p>
<h2 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸"></a>查看元素的几何尺寸</h2><p><code>domEle.getBoundingClientRect();</code><br>兼容性很好，返回的是元素相对其他的最近的有定位的元素的真实的值<br>该方法返回一个对象，对象里面有left,top,right,bottom等属性。left和top代表该元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标<br>height和width代表该元素真实的自身可视高度和宽度。<br>height和width属性老版本IE并未实现<br>返回的结果并不是“实时的”，并且在Google浏览器中扩大缩小页面的内容left和right的值是会跟着变的。其他值是可视区域真实值。</p>
<h2 id="查看元素的尺寸"><a href="#查看元素的尺寸" class="headerlink" title="查看元素的尺寸"></a>查看元素的尺寸</h2><p><code>dom.offsetWidth，dom.offsetHeight</code></p>
<h2 id="查看元素的位置"><a href="#查看元素的位置" class="headerlink" title="查看元素的位置"></a>查看元素的位置</h2><p><code>dom.offsetLeft, dom.offsetTop</code><br>不管dom自身有没有定位，他都会把他跟他最近的有定位的父级元素的距离返回出来。对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。在浏览器下缩放对该方法的取值是有影响的，返回的是真实的可视区域的大小值。<br><code>dom.offsetParent</code><br>返回最近的有定位的父级，如无，返回body，<br><code>documen.body.offsetParent</code>返回null</p>
<h2 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h2><p>eg：求元素相对于文档的坐标getElementPosition<br><code>function getElementPosition(dom) {
  if(dom.offsetParent !== body) {
    return {
      x : dom.offsetLeft,
        y : dom.offsetTop
    }
  }
}</code></p>
<h2 id="让滚动条滚动"><a href="#让滚动条滚动" class="headerlink" title="让滚动条滚动"></a>让滚动条滚动</h2><p>window上有三个方法<br><code>scroll(),scrollTo()       scrollBy();</code><br>三个方法功能类似，用法都是将x,y坐标传入。即实现让滚动轮滚动到当前位置。前两个方法不做累加，是定点到当前所设置位置。<br>区别：scrollBy()会在之前的数据基础之上做累加。</p>
<p>eg：利用scrollBy() 快速阅读的功能    加锁式的编程方法<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="built_in">style</span>='<span class="built_in">width</span>:100px;<span class="built_in">height</span>:100px;<span class="built_in">background</span>-<span class="built_in">color</span>:orange;<span class="built_in">color</span>:#fff;<span class="built_in">font</span>-size:40px;<span class="built_in">font</span>-weight:bold;text-align:<span class="built_in">center</span>;line-<span class="built_in">height</span>:100px;<span class="built_in">position</span>:fixed;bottom:200px;right:50px;<span class="built_in">border</span>-<span class="built_in">radius</span>:<span class="number">50</span><span class="symbol">%</span>;<span class="built_in">opacity</span>:<span class="number">0.5</span>;'&gt; start &lt;/div&gt;</span><br><span class="line">&lt;div <span class="built_in">style</span>='<span class="built_in">width</span>:100px;<span class="built_in">height</span>:100px;<span class="built_in">background</span>-<span class="built_in">color</span>:red;<span class="built_in">color</span>:#fff;<span class="built_in">font</span>-size:40px;<span class="built_in">font</span>-weight:bold;text-align:<span class="built_in">center</span>;line-<span class="built_in">height</span>:100px;<span class="built_in">position</span>:fixed;bottom:400px;right:50px;<span class="built_in">border</span>-<span class="built_in">radius</span>:<span class="number">50</span><span class="symbol">%</span>;<span class="built_in">opacity</span>:<span class="number">0.5</span>;'&gt; stop &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">var</span> start = document.getElementsByTagName('div')[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">var</span> stop = document.getElementsByTagName('div')[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">key</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">timer</span> = <span class="number">0</span>;</span><br><span class="line">    start.onclick = function () &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">key</span>) &#123;</span><br><span class="line">          <span class="built_in">timer</span> = setInterval(function () &#123;</span><br><span class="line">      window.scrollBy(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">          &#125;, <span class="number">100</span>);</span><br><span class="line">          <span class="built_in">key</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stop.onclick = function () &#123;</span><br><span class="line">      clearInterval(<span class="built_in">timer</span>);</span><br><span class="line">      <span class="built_in">key</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="间接控制脚本化CSS属性的方法："><a href="#间接控制脚本化CSS属性的方法：" class="headerlink" title="间接控制脚本化CSS属性的方法："></a>间接控制脚本化CSS属性的方法：</h2><p>读写元素css属性<br><code>dom.style.prop</code><br>可读写行间样式，只能读写行间的值，写到别的地方是读写不出来的。写入操作的唯一方法，其他的方法只能读不能写入了。<br>没有兼容性问题，碰到float这样的关键字属性，前面应加css<br>eg:float — &gt; cssFloat<br>复合属性必须拆解，组合单词变成小驼峰式写法<br>写入的值必须是字符串格式</p>
<h2 id="查询计算样式"><a href="#查询计算样式" class="headerlink" title="查询计算样式"></a>查询计算样式</h2><p>这个方法传入的第二个参数null传入的是什么呢？传入的是获取伪元素，原生的方法。获取伪元素的属性，伪元素的display默认是inline-block；例如获取一个DOM元素div的伪元素的样式表。就是<code>window.getComputedStyle(div, &quot;after&quot;)[&#39;prop&#39;]</code>就是获取的这个div上的伪元素属性after的一些值，但是不能操作，只能取出来。如何改变伪元素的需求呢？当点击一个DOM元素div的时候，让div上的一个伪元素变化。也就是操作CSS的样式上加上一些东西。改变原先的class名字而且先写好CSS样式。</p>
<p><code>window.getComputedStyle(ele,null);</code>显示获取出来的是显示展示能看见的真实值，获取出来的是一个对象，还可以.属性，获取出具体的一个属性值。<br>计算样式只读<br>返回的计算样式的值都是绝对值，没有相对单位（em）<br>IE8 及 IE8以下不兼容</p>
<p>查看IE8及IE8以下的属性的特有的方法<br>查询样式<br><code>ele.currentStyle</code><br>计算样式只读<br>返回的计算样式的值不是经过转换的绝对值<br>IE独有的属性</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>封装兼容性方法getStyle(obj,prop);</strong>  这个方法获取的很靠谱。并且这个方法获取的值是字符串形式的eg“8px”；所以用的时候需要用parseInt()方法来把后面的字符串截断成纯数字形式的，这样我们才能使用。</p>
<p><code>function getStyle(elem, prop) {
  if(window.getComputedStyle) {
    return window.getComputedStyle(elem, null)[prop];
  }else{
    return elem.currentStyle[prop];
  }
}</code></p>
<h1 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h1><p>JSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的）   最开始的时候前后端交流的是使用xml的形式的，但是现在用的是JSON的形式；<br>可以把JSON当成一个构造函数，它里面就有如下两个方法：<br>JSON.parse();   string—&gt;json<br>JSON.stringify();   json—-&gt;string<br>是因为我们传输的信息就是字符串形式的：可以互相转换。</p>
<h2 id="静态类："><a href="#静态类：" class="headerlink" title="静态类："></a>静态类：</h2><p>js是面向过程正在朝面向对象过渡的过程：例如：<br>setInterval() 这个方法是window上的，js上定义的一些方法<br>Math()这个方法，5年前是定义在function Math() {}上的；现在是一个对象。一些方法直接定义在了Math() 身上，所以想用的时候就不用new了，各有各的好处。他们身上的方法就叫做静态方法，静态类的总称。Math.floor()向下取整；Math.ceil()向上取整；Math.abs()取绝对值(absolute);Math.random()  0-1之间的任意小数；Math.sqrt()开方；</p>
<h2 id="时间线："><a href="#时间线：" class="headerlink" title="时间线："></a>时间线：</h2><p>js加载的缺点：加载工具方法没必要阻塞文档，使得js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。<br>有些工具方法需要按需加载，用到再加载，不用不加载。</p>
<h2 id="javascript-异步加载-的-三种方案"><a href="#javascript-异步加载-的-三种方案" class="headerlink" title="javascript 异步加载 的 三种方案"></a>javascript 异步加载 的 三种方案</h2><ol>
<li><p>defer 异步加载，下载完不是立刻执行，是要等到dom文档全部解析完才会被执行。只有IE能用。IE10以下的可用。不光是页面内的js文件还是页面外引入的都会变成异步加载的。<br><script type="text/javascript" defer="defer" src="xxx.js"></script>可以简化成defer<br>就比如说页面中有一个img标签，先解析，加到DOM树上；再加载，比如图片需要加载图片的二进制文档，也就是下载，下载完了也就是加载完了；最后绘制渲染出来。</p>
</li>
<li><p>async 异步加载，加载完就执行，async只能加载外部脚本，不能把js写在script 标签里。这个方法只能是加载外部js引用时才能异步加载。<br><script type="text/javascript" async="async" src="xxx.js"></script><br>asynchronous javascript and xml —–&gt;  Ajax</p>
</li>
</ol>
<p>1和2 执行时也不阻塞页面，但是不能两个同时用。一般公司都会采用牺牲IE的方法只用async的。</p>
<ol start="3">
<li>创建script，插入到DOM中，加载完毕后callBack</li>
</ol>
<h2 id="按需加载异步下载js的兼容性写法："><a href="#按需加载异步下载js的兼容性写法：" class="headerlink" title="按需加载异步下载js的兼容性写法："></a>按需加载异步下载js的兼容性写法：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.type = <span class="string">"text/jacascript"</span>;</span><br><span class="line">  script.src = url;</span><br><span class="line">  <span class="keyword">if</span>(script.readyState) &#123;</span><br><span class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(script.readyState == <span class="string">"complete"</span> ||  script.readyState == <span class="string">"loaded"</span>) &#123;</span><br><span class="line">	  callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    script.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">'tools.js'</span>, getScrollOffset);</span><br></pre></td></tr></table></figure>
<p>这里有一个问题，就是还没等到工具js包下载完呢，就调用这个包里面的方法肯定会报错的。解决方法为可以<code>loadScript(&#39;tools.js&#39;, function() {console.log(getScrollOffset())});</code>或者把tools.js里面的方法都整合到一个对象里面：在js包里： <code>var obj={getScrollOffset: function() {console.log(&#39;a&#39;)}};</code>然后再把上面这个方法也改了，改成  <code>obj[callback]();</code>这样就可以这样用了<code>loadScript(&#39;tools.js&#39;, &#39;getScrollOffset&#39;);</code></p>
<h2 id="js时间线："><a href="#js时间线：" class="headerlink" title="js时间线："></a>js时间线：</h2><ol>
<li>创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。</li>
<li>遇到link外部css，创建线程加载，并继续解析文档。</li>
<li>遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</li>
<li>遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。<br>对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()因为该方法会清空之前写的所有文档流）</li>
<li>遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</li>
<li>当文档解析完成，document.readyState = ‘interactive’。</li>
<li>文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;</li>
<li>当文档解析完成后，document对象触发DOMContentLoaded事件，一触发就标志着解析完毕了。这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</li>
<li>当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，也就是当所有的东西都加载完成之后，window对象触发load事件。加载完成就开始渲染，所有的东西都就画出来了，用户可以看见东西了。</li>
<li>从此，以异步响应方式处理用户输入、网络事件等。</li>
</ol>
<p><strong>绑定事件的时候，无论多少的单词都不会大写的，但是只有一个特殊的就是’DOMContentLoaded’。</strong><br><code>document.readyState 三个阶段：loading、interactive、comolete.</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样打印出来就是： ‘interactive’<br>再复习一下第三个参数false是什么意思呢，就是捕获，绑定事件监听的事件处理模型只能有两种行为，一个是捕获，另一个是冒泡。true的时候就是冒泡。</p>
<h2 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h2><p><strong>请编写一段JavaScript脚本生成下面这段DOM结构。要求：使用标准的DOM方法或属性。</strong><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"example"</span>&gt;</span><br><span class="line">	&lt;p <span class="built_in">class</span>=<span class="string">"slogan"</span>&gt;姬成，你最帅!&lt;/p&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>提示 dom.className 可以读写class<br><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">div</span> = document.createElement(<span class="string">'div'</span>),</span><br><span class="line">    p = document.createElement(<span class="string">'p'</span>);</span><br><span class="line">p.innerText = <span class="string">'姬成，你最帅！'</span>;      也可以  <span class="keyword">var</span> text = document.createTextNode(<span class="string">'姬成，你最帅！'</span>);</span><br><span class="line"><span class="keyword">div</span>.appendChild(p);</span><br><span class="line">document.body.appendChild(<span class="keyword">div</span>);</span><br><span class="line"><span class="keyword">div</span>.setAttribute(<span class="string">'class'</span>, <span class="string">'example'</span>);</span><br><span class="line">p.setAttribute(<span class="string">'class'</span>, <span class="string">'slogan'</span>);</span><br><span class="line">有一个注意的点就时appendChild()括号里没有<span class="string">''</span>!!! 应该直接在里面写原生DOM   appendChild(<span class="keyword">div</span>)</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>封装函数insertAfter()；功能类似insertBefore();<br>提示:可忽略老版本浏览器，直接在Element.prototype上编程</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.insertAfter = <span class="function"><span class="keyword">function</span> <span class="params">(targetNode, afterNode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> beforeNode = afterNode.nextElementSibling;</span><br><span class="line">  <span class="keyword">if</span>(beforeNode) &#123;</span><br><span class="line">    <span class="keyword">this</span>.insertBefore(targetNode, beforeNode);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.appendChild(targetNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将目标节点内部的节点顺序逆序。<br>eg:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"> </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">Element.prototype<span class="built_in">.reverse</span> = <span class="keyword">function</span> (dom) &#123;</span><br><span class="line">  var len = this.length;</span><br><span class="line">  <span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    this.</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="作业区："><a href="#作业区：" class="headerlink" title="作业区："></a>作业区：</h1><ol>
<li><p>遍历元素节点树，要求不能用children属性</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	</span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">var div =<span class="built_in"> document</span>.getElementByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">function</span> retElementChild(<span class="type">node</span>) &#123;</span><br><span class="line">  var temp = &#123;</span><br><span class="line">     length : <span class="number">0</span>,</span><br><span class="line">     push : Array.prototype.push,</span><br><span class="line">     splice : Array.prototype.splice</span><br><span class="line">  &#125;,</span><br><span class="line">      child = <span class="type">node</span>.childNodes,</span><br><span class="line">      len = child.length;</span><br><span class="line">  <span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">     <span class="keyword">if</span>(child[i].nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">	temp.push(child[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retElement(div)</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装函数，返回元素e的第n层祖先元素</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	</span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> retParent(elem, n) &#123;</span><br><span class="line">  while(n &amp;&amp; elem) &#123;</span><br><span class="line">    elem = elem.parentElement;</span><br><span class="line">    n --;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0，返回自己。</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;span&gt;</span><br><span class="line">     &lt;p&gt;</span><br><span class="line">	&lt;strong&gt;</span><br><span class="line">	  &lt;em&gt;&lt;/em&gt;</span><br><span class="line">	&lt;/strong&gt;</span><br><span class="line">     &lt;/p&gt;</span><br><span class="line">   &lt;/span&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">function retSibing(<span class="built_in">e</span>, n) &#123;</span><br><span class="line">  <span class="keyword">while</span>(n &amp;&amp; <span class="built_in">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">e</span>.nextElementSibling) &#123;</span><br><span class="line">          <span class="built_in">e</span> = <span class="built_in">e</span>.nextElementSibling;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	  <span class="keyword">for</span>(var <span class="built_in">e</span> = <span class="built_in">e</span>.nextSibling; <span class="built_in">e</span> &amp;&amp; <span class="built_in">e</span>.nodeType != <span class="number">1</span>; <span class="built_in">e</span> = <span class="built_in">e</span>.nextSibling);</span><br><span class="line">	&#125;</span><br><span class="line">	n --;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">e</span>.previousElementSibling) &#123;</span><br><span class="line">	  <span class="built_in">e</span> = <span class="built_in">e</span>.previousElementSibling;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	  <span class="keyword">for</span>(var <span class="built_in">e</span> = <span class="built_in">e</span>.previousSibling; <span class="built_in">e</span> &amp;&amp; <span class="built_in">e</span>.nodeType != <span class="number">1</span>; <span class="built_in">e</span> = <span class="built_in">e</span>.previousSibling);</span><br><span class="line">	&#125;</span><br><span class="line">	n ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑函数，封装children功能，解决以前部分浏览器的兼容性问题,就是用自己的方法实现children方法。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	</span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">var div =<span class="built_in"> document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">Element.prototype.myChildren = <span class="keyword">function</span> () &#123;</span><br><span class="line"> var child = this.childNodes,</span><br><span class="line">     len = child.length,</span><br><span class="line">     arr = [];</span><br><span class="line"> <span class="keyword">for</span>(var i = <span class="number">0</span>；i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(child[i].nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">	arr.push(child[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">div.myChildren();    结果为：[span]</span><br></pre></td></tr></table></figure>
</li>
<li><p>自己封装hasChildren()方法，不可用children属性。如果有元素节点返回true，如果没有返回false。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">	</span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">var div =<span class="built_in"> document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">Element.prototype.hasChildren = <span class="keyword">function</span> () &#123;</span><br><span class="line">  var child = this.childNodes,</span><br><span class="line">      len = child.length,</span><br><span class="line">      arr = [];</span><br><span class="line">  <span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">     <span class="keyword">if</span>(child[i].nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span><span class="built_in"> true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span><span class="built_in"> false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.hasChildren();   结果<span class="built_in">：true</span>;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-2017/11/JavaScript之V8引擎" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/11/JavaScript之V8引擎.html" class="article-date">
      <time datetime="2022-11-05T14:53:17.296Z" itemprop="datePublished">2022-11-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2017/11/JavaScript之V8引擎.html">JavaScript之V8引擎</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>JavaScript之V8引擎</strong>     <Excerpt in index | 首页摘要><br>V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。<br>V8在执行之前将JavaScript代码编译成机器码让计算机识别执行，而非字节码或者直译它，以此来提升效能，JavaScript程序与V8引擎的速度可以媲美二进制编译。在高性能JavaScript一书中作者有比较V8引擎与其他语言的执行速度，作者列成了图表很清楚的显示出JavaScript引擎V8不俗的执行速度。</p>
<p>V8是Google Chrome浏览器内置的JavaScript脚本引擎。<br>Google Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。<br>V8引擎编译和执行JavaScript源代码。<br>速度是V8引擎追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码 + 解释器”的引擎，优势不言而喻。<br>V8引擎的团队说Chrome对脚本的解析和执行速度是Firefox和Safari的10倍，是IE的56倍。当然了，自夸自家的瓜甜，都是这样的嘛~最近不是新出了Safari又比Google Chrome快了80%的速度吗~但是只是因为Safari更新的比较快，优化了最新的ES6，所以与之前未做优化的Chrome相比快了不少~也是真能吹牛哈~</p>
<hr>
<p>正是由于V8的高性能，所以基于nodejs开发的引擎就是V8引擎。</p>
<hr>
<p>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。V8的JavaScript渲染引擎亮点在于更快速更强壮的JavaScript解析。V8是一个非常反传统的JavaScript引擎，它能够在后台动态的对JS的对象进行分类——一个在其他高级语言中很常见但JS本身不支持的特性。V8对JS的解析不是基于反复loop源代码进行解释而是直接将JS代码编译成机器码运行。换句话说，V8引擎实际上可以看做是JS的扩展和编译器——而传统上类似于JS的解释型语言恰恰是不需要编译器的。最后，高级语言的内存管理效能一直是决定其运行效率的重要因素，而当前的JS虚拟机在这方面做的比较基本，对内存的回收也非常保守。V8使用的是非常强势的内存管理策略，一切在运行堆栈里无用的数据都会被强行回收，从而可以大大提高JS代码的运行效率。<br>在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。</p>
<p>和Mozilla的SpiderMonkey一样，Google Chrome浏览器的JavaScript引擎Google V8也是一个开源的独立引擎，可内嵌于任何C++工程之中。</p>
<blockquote>
<p>速度是V8追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。在SunSpider测试中，V8的综合表现是最好的。据说Mozilla正在开发的TraceMonkey比V8还要快20%左右，可惜尚未完工。</p>
</blockquote>
<h1 id="JavaScript的发展"><a href="#JavaScript的发展" class="headerlink" title="JavaScript的发展"></a>JavaScript的发展</h1><blockquote>
<p>Netscape Navigator 在 90 在年代中期对 JavaScript 进行了集成，这让网页开发人员对 HTML 页面中诸如 form 、frame 和 image 之类的元素的访问变得非常容易。由此 JavaScript 很快成为了用于定制控件和添加动画的工具，到 90 年代后期的时候，大部分的 JavaScript 脚本仅仅完成像“根据用户的鼠标动作把一幅图换成另一幅图”这样简单的功能。</p>
</blockquote>
<blockquote>
<p>随着最近 AJAX 技术的兴起，JavaScript 现在已经变成了实现基于 web 的应用程序（例如我们自己的 Gmail）的核心技术。JavaScript 程序从聊聊几行变成数百 KB 的代码。JavaScript 被设计于完成一些特定的任务，虽然 JavaScript 在做这些事情的时候通常都很高效，但是性能已经逐渐成为进一步用 JavaScript 开发复杂的基于 web 的应用程序的瓶颈。</p>
</blockquote>
<blockquote>
<p>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。其中的原因在你读过这份文档余下的部分之后就会明白了。</p>
</blockquote>
<h1 id="V8-的性能提升主要来自三个关键部分："><a href="#V8-的性能提升主要来自三个关键部分：" class="headerlink" title="V8 的性能提升主要来自三个关键部分："></a>V8 的性能提升主要来自三个关键部分：</h1><ol>
<li>快速属性访问</li>
<li>动态机器码生成</li>
<li>高效的垃圾收集</li>
</ol>
<h2 id="快速属性访问"><a href="#快速属性访问" class="headerlink" title="快速属性访问"></a>快速属性访问</h2><p>JavaScript 是一门动态语言，属性可以在运行时添加到或从对象中删除。这意味着对象的属性经常会发生变化。大部分 JavaScript 引擎都使用一个类似于字典的数据结构来存储对象的属性，这样每次访问对象的属性都需要进行一次动态的字典查找来获取属性在内存中的位置。这种实现方式让 JavaScript 中属性的访问比诸如 Java 和 Smalltalk 这样的语言中的成员变量的访问慢了许多。成员变量在内存中的位置离对象的地址的距离是固定的，这个偏移量由编译器在编译的时候根据对象的类的定义决定下来。因此对成员变量的访问只是一个简单的内存读取或写入的操作，通常只需要一条指令即可。</p>
<p>为了减少 JavaScript 中访问属性所花的时间，V8 采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。这并不是什么新的想法，基于原型的编程语言 Self 就用 map 来实现了类似的功能（参见 An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes ）而且JavaScript在创建之初因为是赶时间赶出来的（10天的时间，而且还是Brendan Eich为了应付公司安排的任务的~），所以也正是借鉴了很多语言的长处，也就是上面所说的self语言和C语言等等（有一句话说的好：与其说我爱JavaScript，不如说我恨她；她是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：“她的优秀之处并非原创，她的原创之处并不优秀”）。在 V8 里，当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。</p>
<p>下面我们用一个简单的 JavaScript 函数来加以说明：</p>
<p><code>function Point(x, y) {
    this.x = x;
    this.y = y;
}</code></p>
<p>当 new Point(x, y) 执行的时候，一个新的 Point 对象会被创建出来。如果这是 Point 对象第一次被创建，V8 会为它初始化一个隐藏类，不妨称作 C0。因为这个对象还没有定义任何属性，所以这个初始类是一个空类。到这个时候为止，对象 Point 的隐藏类是 C0。</p>
<p>map_trans_a<br>执行函数 Point 中的第一条语句（this.x = x;）会为对象 Point 创建一个新的属性 x。此时，V8 会：<br>在 C0 的基础上创建另一个隐藏类 C1，并将属性 x 的信息添加到 C1 中：这个属性的值会被存储在距 Point 对象的偏移量为 0 的地方。<br>在 C0 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 x 之后能够找到 C1 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C1。</p>
<ol>
<li>map_trans_b<br>执行函数 Point 中的第二条语句（this.y = y;）会添加一个新的属性 y 到对象 Point 中。同理，此时 V8 会：<br>在 C1 的基础上创建另一个隐藏类 C2，并在 C2 中添加关于属性 y 的信息：这个属性将被存储在内存中离 Point 对象的偏移量为 1 的地方。<br>在 C1 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 y 之后能够找到 C2 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C2。</li>
<li>map_trans_c<br>咋一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息，隐藏类可以被重用。下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。例如，如果又一个 Point 对象被创建出来了：<br>一开始 Point 对象没有任何属性，它的隐藏类将会被设置为 C0。<br>当属性 x 被添加到对象中的时候，V8 通过 C0 到 C1 的类转移信息将对象的隐藏类更新为 C1 ，并直接将 x 的属性值写入到由 C1 所指定的位置（偏移量 0）。<br>当属性 y 被添加到对象中的时候，V8 又通过 C1 到 C2 的类转移信息将对象的隐藏类更新为 C2，并直接将 y 的属性值写入到由 C2 所指定的位置（偏移量 1）。</li>
</ol>
<p>尽管 JavaScript 比通常的面向对象的编程语言都要更加动态一些，然而大部分的 JavaScript 程序都会表现出像上述描述的那样的运行时高度结构重用的行为特征来。使用隐藏类主要有两个好处：属性访问不再需要动态字典查找了；为 V8 使用经典的基于类的优化和内联缓存技术创造了条件。</p>
<h2 id="动态机器码生成"><a href="#动态机器码生成" class="headerlink" title="动态机器码生成"></a>动态机器码生成</h2><p>V8 在第一次执行 JavaScript 代码的时候会将其直接编译为本地机器码，而不是使用中间字节码的形式，因此也没有解释器的存在。属性访问由内联缓存代码来完成，这些代码通常会在运行时由 V8 修改为合适的机器指令。</p>
<p>在第一次执行到访问某个对象的属性的代码时，V8 会找出对象当前的隐藏类。同时，V8 会假设在相同代码段里的其他所有对象的属性访问都由这个隐藏类进行描述，并修改相应的内联代码让他们直接使用这个隐藏类。当 V8 预测正确的时候，属性值的存取仅需一条指令即可完成。如果预测失败了，V8 会再次修改内联代码并移除刚才加入的内联优化。</p>
<p>例如，访问一个 Point 对象的 x 属性的代码如下：</p>
<p>point.x</p>
<p>在 V8 中，对应生成的机器码如下：</p>
<p><code>; ebx = the point objectcmp [ebx, &lt;hidden class offset&gt;], &lt;cached hidden class&gt;
jne &lt;inline cache miss&gt;
mov eax, [ebx, &lt;cached x offset&gt;]</code></p>
<p>如果对象的隐藏类和缓存的隐藏类不一样，执行会跳转到 V8 运行系统中处理内联缓存预测失败的地方，在那里原来的内联代码会被修改以移除相应的内联缓存优化。如果预测成功了，属性 x 的值会被直接读出来。</p>
<p>当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，让大部分 JavaScript 代码的运行效率得以大幅提升。</p>
<h2 id="高效的垃圾回收机制"><a href="#高效的垃圾回收机制" class="headerlink" title="高效的垃圾回收机制"></a>高效的垃圾回收机制</h2><p>V8 会自动回收不再被对象使用的内存，这个过程通常被称为“垃圾收集（Garbage Collection）”。为了保证快速的对象分配和缩短由垃圾收集造成的停顿，并杜绝内存碎片，V8 使用了一个 stop-the-world, generational, accurate 的垃圾收集器，换句话说，V8 的垃圾收集器：</p>
<ol>
<li>在执行垃圾回收的时候会中断程序的执行。</li>
<li>大部分情况下，每个垃圾收集周期只处理整个对象堆的一部分，这让程序中断造成的影响得以减轻。</li>
<li>总是知道内存中所有的对象和指针所在的位置，这避免了非 accurate 的垃圾收集器中普遍存在的由于错误地把对象当作指针而造成的内存溢出的情况。</li>
</ol>
<p>在 V8 中，对象堆被分成两部分：用于为新创建的对象分配空间的部分和用于存放在垃圾收集周期中生存下来的那些老的对象的部分。如果一个对象在垃圾收集的过程中被移动了，V8 会更新所有指向这个对象的指针到新的地址。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/认知提升/">认知提升</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-2017/11/CSS技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/11/CSS技巧.html" class="article-date">
      <time datetime="2022-11-05T14:53:17.295Z" itemprop="datePublished">2022-11-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2017/11/CSS技巧.html">CSS小技巧</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong> CSS小技巧：</strong> <Excerpt in index | 首页摘要><br>清除浮动元素的技巧解析:<br>display:block;<br>height:0;<br>line-height:0;<br>content:’ ‘;<br>clear:both;<br>visibility:hidden;<br>这些是设置在元素的伪元素上的，比如要是想在当前元素的后面设置清除浮动，那就设置元素的:after设置上面的属性；要是想在当前元素的前面清除浮动，那就设置当前元素的:before上设置前面的属性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-2017/11/CSS3中transform的加速问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/11/CSS3中transform的加速问题.html" class="article-date">
      <time datetime="2022-11-05T14:53:17.294Z" itemprop="datePublished">2022-11-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2017/11/CSS3中transform的加速问题.html">使用CSS3开启GPU硬件加速提升网站动画渲染性能</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong> 使用CSS3开启GPU硬件加速提升网站动画渲染性能 </strong> <Excerpt in index | 首页摘要></p>
<p>今天再来说一下CSS3中的新特性，transform。说他之前先来解释图片中的两个格式的区别：PNG8和PNG24。</p>
<h1 id="png8"><a href="#png8" class="headerlink" title="png8"></a>png8</h1><p>每一张“png8”图像，都最多只能展示256种颜色，所以“png8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；</p>
<h1 id="png-24"><a href="#png-24" class="headerlink" title="png 24"></a>png 24</h1><p>每一张“png24”图像，可展示的颜色就远远多于“png8”了，最多可展示的颜色数量可多达1600万；所以“png24”所展示的图片颜色会更丰富，图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“png24”的图片比较适合像摄影作品之类颜色比较丰富的图片；</p>
<p>所以一些网站如果需要加载一些很大的PNG24类型的图片的话，那么图片加载的时间就会有点长甚至导致网站出现卡顿现象，进而影响用户体验。我们如何解决这个问题呢？或者说如何优化这个麻烦呢？这就需要我们今天要说到的CSS3中的transform属性了。为什么添加这个属性之后就会提升性能呢？因为为动画DOM元素添加CSS3样式-webkit-transform:transition3d(0,0,0)或-webkit-transform:translateZ(0);，这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画时从CPU转向GPU，其实说白了这是一个小伎俩，也可以算是一个Hack，-webkit-transform:transition3d和-webkit-transform:translateZ其实是为了渲染3D样式，但我们设置值为0后，并没有真正使用3D效果，但浏览器却因此开启了GPU硬件加速模式。<br>　　这种GPU硬件加速在当今PC机及移动设备上都已普及，在移动端的性能提升是相当显著地，所以建议大家在做动画时可以尝试一下开启GPU硬件加速。</p>
<p>当然也可以这样开启所有浏览器的GPU硬件加速：</p>
<blockquote>
<p>-webkit-transform: translateZ(0);<br>-moz-transform: translateZ(0);<br>-ms-transform: translateZ(0);<br>-o-transform: translateZ(0);<br>transform: translateZ(0);</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>-webkit-transform: translate3d(0,0,0);<br>-moz-transform: translate3d(0,0,0);<br>-ms-transform: translate3d(0,0,0);<br>-o-transform: translate3d(0,0,0);<br>transform: translate3d(0,0,0);</p>
</blockquote>
<p>但是我们要注意的是：开启GUI加速之后，会出现一些意想不到的BUG问题。当你有多个position:absolute;元素添加-webkit-transform:transition3d(0,0,0);开启GPU硬件加速之后，会有几个元素凭空消失，调试许久无果遂Google之，国内暂时没有人发表过关于这类问题的文章，于是在国外网站找呀找，找到了很多与我遇到同样问题的人，但都没有真正靠谱的解决办法，这可能是跟添加-webkit-transform之后chrome尝试使用GPU硬件加速有关系。<br>在使用-webkit-transform尝试对很多DOM元素编写3D动画时，尽量不要对这些元素及他们的父元素使用position:absolute/fixed。(其实这种情况很难避免)</p>
<p>通过-webkit-transform:transition3d/translateZ开启GPU硬件加速之后，有些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决之：</p>
<blockquote>
<p>-webkit-backface-visibility:hidden;<br>-webkit-perspective:1000;</p>
</blockquote>
<p>通过-webkit-transform:transition3d/translateZ开启GPU硬件加速的适用范围：</p>
<ol>
<li>使用很多大尺寸图片(尤其是PNG24图)进行动画的页面。</li>
<li>页面有很多大尺寸图片并且进行了css缩放处理，页面可以滚动时。</li>
<li>使用background-size:cover设置大尺寸背景图，并且页面可以滚动时。(详见: <a href="https://coderwall.com/p/j5udlw">https://coderwall.com/p/j5udlw</a> )</li>
<li>编写大量DOM元素进行CSS3动画时(transition/transform/keyframes/absTop&amp;Left)</li>
<li>使用很多PNG图片拼接成CSS Sprite时</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS3/">CSS3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-2017/11/CSS3-简介" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/11/CSS3-简介.html" class="article-date">
      <time datetime="2022-11-05T14:53:17.294Z" itemprop="datePublished">2022-11-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2017/11/CSS3-简介.html">CSS3新增加的功能和属性方法--之选择器</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="CSS3—选择器"><a href="#CSS3—选择器" class="headerlink" title="CSS3—选择器"></a>CSS3—选择器</h1><p>提供了更加强大且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状、角度等，可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等等等…</p>
<p>  在CSS3的一些新特性或方法还没正式使用之前，有一些浏览器商为了竞争用户使用人数或者说是为了一些商业目的，在CSS3还没有正式通过使用时就在自家的浏览器上实现了CSS3新出的功能。而这些浏览器商为了显示出这是自家的浏览器上实现的CSS3新功能，所以他们就在新实现的CSS3功能的属性之前加上了自家的标志。添加的前缀标志如下：<br>  在编写CSS3样式时，不同的浏览器可能需要不同的前缀。它表示该CSS属性或规则尚未成为W3C标准的一部分，是浏览器的私有属性，虽然目前较新版本的浏览器都是不需要前缀的，但为了更好的向前兼容前缀还是少不了的。</p>
<h3 id="以CSS3新属性border-radius为例："><a href="#以CSS3新属性border-radius为例：" class="headerlink" title="以CSS3新属性border-radius为例："></a>以CSS3新属性border-radius为例：</h3><blockquote>
<p>-webkit-border-radius<br>Chrome和Safari</p>
<p>-moz-border-radius<br>Firefox</p>
<p>-ms-border-radius<br>IE</p>
<p>-o-border-radius<br>Opera</p>
</blockquote>
<p>CSS3新添加的属性方法有哪些?</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>添加圆角 – border-radius 这是一个复合属性，分别为代表左上角、右上角、右下角、左下角；而且他们的所代表的左上角还是一个小的复合属性，又可以分成x轴和y轴的偏移量。 还有一种写法border-radius： 1em 2em 3em 4em / 2em 3em 4em 5em;</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>添加盒子阴影 –  box-shadow  这也是一个复合属性，是添加盒子阴影的方法。<br>box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];  []里面的属性代表可以省略的属性。需要注意的是最后的一个可选属性即投影方式默认是outset投影方式，如果想设置成默认向外投影方式的话，一定注意不要把这个属性值写上去，写上去的话就不好使了，就没有阴影了，但是如果想改变投影方式为其他的形式需要写上去的。同一盒子，可以同时加多个阴影，阴影之间用“,”隔开。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>添加文本阴影  text-shadow<br>语法<br>text-shadow:X-Offset Y-Offset blur color;<br>X-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移；<br>Y-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移<br>Blur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0；<br>Color：是指阴影的颜色，其可以使用rgba色。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>颜色值RGBA  再原先RGB的基础上添加了透明度这一参数。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>CSS3的渐变分为两种<br>1）线性渐变（linear - to）<br>语法: linear-gradient([direction], color [percent], color [percent], …)<br>[] 内为选填<br>direction角度的单位为 “deg” 也可以用to bottom, to left, to top left等的方式来表达<br>2）径向渐变（radial - at）<br>语法:radial-gradient(shape at position, color [percent] , color, …)<br>shape:放射的形状，可以为原型circle，可以为椭圆ellipse<br>position: 圆心位置，可以两个值，也可以一个，如果为一个时，第二个值默认center 即 50%。值类型可以为，百分数，距离像素，也可以是方位值(left,top…); /<em>x 轴主半径 y轴次半径</em>/</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>文字边界换行<br>word-wrap:normal|break-word;</p>
<h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>可以下载网上的好看的字体想要引入的话就用下面的方式把下载到包用到我们的网页上，字体的包有很多格式，有的浏览器不支持某一种格式的话就换一种：<br><code>font-face
@font-face{
font-family:”myFirstFont”;
src:url(&#39;Sansation_Light.ttf&#39;),
url(‘Sansation_Light.eot&#39;) format(‘eot’)；下载前面的优先选用
}
@font-face {
    font-family: &#39;diyfont&#39;;
    src: url(&#39;diyfont.eot&#39;); /* IE9+ */
    src: url(&#39;diyfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */
         url(&#39;diyfont.woff&#39;) format(&#39;woff&#39;), /* chrome、firefox */
         url(&#39;diyfont.ttf&#39;) format(&#39;truetype&#39;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
         url(&#39;diyfont.svg#fontname&#39;) format(&#39;svg&#39;); /* iOS 4.1- */
}</code><br><a href="https://www.w3cplus.com/content/css3-font-face">字体</a> (字体包下载地址)<br><a href="www.dafont.com">字体</a> (字体包下载地址)</p>
<h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>border-image方法–边框应用背景<br>border-image: url(xxx.png)  number<br>               stretch 很好理解就是拉伸，有多长拉多长。有多远“滚”多远<br>               repeat (和4角上 同等大小图片进行平铺  当边框中间区域长度不是4角图片大小的整数倍时 会被切割)<br>               铺满(round)(4角上的图片 进行拉伸平铺  不会被切割)<br>（共三个参数）<br>number 为截取指定图片四周的宽度作为border的背景填充部分(截取图可按border-width 大小伸缩), number为一个数字时是复合写法。最后一个属性为border-image的展示策略</p>
<h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p>背景图片起始位置background-origin<br>语法：<br>background-origin ： border-box | padding-box | content-box;<br>参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。</p>
<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>裁剪背景图片background-clip<br>语法：<br>background-clip ： border-box | padding-box | content-box | no-clip<br>参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。background-clip默认值为border-box。<br>text : background-clip : text ;<br>从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果。这个很炫哦~~<br>注意：webkit独有属性，且必须配合text-fill-color属性<br><code>-webkit-background-clip:text;-webkit-text-fill-color:transparent;
text-fill-color:-webkit-background-clip;
-webkit-background-clip: text;
-webkit-text-fill-color:transparent;</code></p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>背景图片尺寸background-size<br>设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。<br>语法：<br>background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain<br>取值说明：</p>
<ol>
<li>auto：默认值，不改变背景图片的原始高度和宽度；</li>
<li>&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；</li>
<li>&lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；</li>
<li>cover：用一张图片铺满整个背景，如果比例不符，则截断图片</li>
<li>contain：尽量让背景内，存在一整张图片</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/必备知识/">必备知识</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS3/">CSS3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-2017/11/CSS3-选择器的使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/11/CSS3-选择器的使用.html" class="article-date">
      <time datetime="2022-11-05T14:53:17.294Z" itemprop="datePublished">2022-11-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2017/11/CSS3-选择器的使用.html">CSS3选择器的使用方法</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>增加了可以使用正则匹配属性名的方法：<br>E[att^=“val”] {…}  选择匹配元素E, 且E元素定义了属性att, 其属性值以val开头的任何字符串<br>E[att$=“val”]{…}选择匹配元素E, 且E元素定义了属性att, 其属性值以val结尾的任何字符串<br>E[att*=“val”]{…}选择匹配元素E, 且E元素定义了属性att, 其属性值任意位置出现了“val”。即属性值包含了“val”，位置不限。</p>
<h2 id="初级伪类选择器：伪类用于向某些选择器添加特殊的效果。"><a href="#初级伪类选择器：伪类用于向某些选择器添加特殊的效果。" class="headerlink" title="初级伪类选择器：伪类用于向某些选择器添加特殊的效果。"></a>初级伪类选择器：伪类用于向某些选择器添加特殊的效果。</h2><h3 id="1-root-根标签选择器"><a href="#1-root-根标签选择器" class="headerlink" title="1.root 根标签选择器"></a>1.root 根标签选择器</h3><p>“:root”选择器等同于<html>元素，简单点说：<br>:root{background:orange}<br>html{background:orange}<br>得到的效果等同<br>建议使用:root（xml等）</p>
<h3 id="2-not-否定选择器"><a href="#2-not-否定选择器" class="headerlink" title="2.not 否定选择器"></a>2.not 否定选择器</h3><p>用法和jQuery 中的not类似，可以排除某些特定条件的元素<br>div:not([class=“demo”]){<br>background-color:red;<br>}<br>意思为除了class为demo的div以外，所有的div的背景颜色都变红</p>
<h3 id="3-empty-空标签选择器"><a href="#3-empty-空标签选择器" class="headerlink" title="3.empty 空标签选择器"></a>3.empty 空标签选择器</h3><p>用来选择没有内容的元素、不在文档树中的元素，这里的没有内容指的是一点内容都没有，哪怕是一个空格。</p>
<h3 id="4-target-目标元素选择器"><a href="#4-target-目标元素选择器" class="headerlink" title="4.target 目标元素选择器"></a>4.target 目标元素选择器</h3><p>用来匹配被location.hash 选中的元素(即锚点元素)<br>选择器可用于选取当前活动的目标元素，被设置为锚点的元素被锚点之后就可以显示相应的css样式。</p>
<h3 id="5-first-child-第一个子元素"><a href="#5-first-child-第一个子元素" class="headerlink" title="5.:first-child 第一个子元素"></a>5.:first-child 第一个子元素</h3><p>:last-child 最后一个子元素<br>:nth-child(){} 第xxx个子元素，n代表变量自然数<br>:nth-last-child(){}  从后往前数<br>以上四个选择器均有弊端，即如果当前位置元素不是前面所修饰的元素，那么无效<br>注：其父元素的第 N 个子元素，不论元素的类型。</p>
<h3 id="6-first-of-type-第一个子元素"><a href="#6-first-of-type-第一个子元素" class="headerlink" title="6.:first-of-type 第一个子元素"></a>6.:first-of-type 第一个子元素</h3><p>:last-of-type 最后一个子元素<br>:nth-of-type(){} 第xxx个子元素，n代表变量自然数<br>:nth-last-of-type(){}  从后往前数<br>此种选择器，限制了类型，即在所修饰元素的类型下选择特定位置的元素。</p>
<h3 id="7-only-child-唯一子元素选择器"><a href="#7-only-child-唯一子元素选择器" class="headerlink" title="7 :only-child  唯一子元素选择器"></a>7 :only-child  唯一子元素选择器</h3><p>选择是独生子的子元素，即该子元素不能有兄弟元素，它的父元素只有他一个直接子元素。<br>注意：选择的元素是独生子子元素，而非有唯一子元素的父元素。<br>:only-of-type<br>如果要选择第某类特定的子元素(p) 在兄弟节点中是此类元素唯一个的话 就需要用到这个属性了</p>
<h3 id="8-enabled-可用的元素-disabled-不可用的元素"><a href="#8-enabled-可用的元素-disabled-不可用的元素" class="headerlink" title="8 :enabled  可用的元素   :disabled 不可用的元素"></a>8 :enabled  可用的元素   :disabled 不可用的元素</h3><p>在web的表单中，有些表单元素有可用（“enabled”）和不可用（“disabled”）状态，比如输入框，密码框，复选框等。在默认情况下，这些表单元素都处在可用状态。那么我们可以通过伪类选择器 enabled 进行选择，disabled则相反。</p>
<h3 id="9-checked-选择框的被选中状态"><a href="#9-checked-选择框的被选中状态" class="headerlink" title="9:checked  选择框的被选中状态"></a>9:checked  选择框的被选中状态</h3><p>注：checkbox, radio 的一些默认状态不可用属性进行改变，如宽高颜色。</p>
<h3 id="10-read-only-选中只读的元素"><a href="#10-read-only-选中只读的元素" class="headerlink" title="10:read-only  选中只读的元素"></a>10:read-only  选中只读的元素</h3><p>eg:<code>&lt;input type=“text” readonly=“readonly”/&gt;</code><br>:read-write 选中非只读的元素<br>eg:<code>&lt;input type=“text”/&gt;</code></p>
<h5 id="扩张内容：伪类与伪元素的区别"><a href="#扩张内容：伪类与伪元素的区别" class="headerlink" title="扩张内容：伪类与伪元素的区别"></a>扩张内容：伪类与伪元素的区别</h5><blockquote>
<p>伪类的效果可以通过添加一个实际的类来达到。<br>伪元素的效果则需要通过添加一个实际的元素才能达到。<br>这也是为什么他们一个称为伪类，一个称为伪元素的原因。</p>
</blockquote>
<h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p>CSS3对伪元素进行了一定的调整，在以前的基础上增加了一个:也就是现在变成了::first-letter,::first-line,::before,::after<br>另外还增加了一个::selection</p>
<h3 id="1-selection"><a href="#1-selection" class="headerlink" title="1.::selection"></a>1.::selection</h3><p>“::selection” 选择器是用来匹配突出显示的文本（用鼠标选择文本的时候）。浏览器默认情况下，用鼠标选择网页文本是以“蓝色的北京，白色的字体”显示的。<br>属性：user-select: none;<br>注：火狐下必须加-moz-<br>-moz-::selection</p>
<h2 id="条件选择"><a href="#条件选择" class="headerlink" title="条件选择"></a>条件选择</h2><p>E &gt; F  an F element child of an E element<br>直接子元素<br>E + F an F element immediately preceded by an E element<br>后面的紧挨着的兄弟节点<br>E ~ F an F element preceded by an E element<br>后面的兄弟节点</p>
<pre><code>Author:By--Dexinser
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/必备知识/">必备知识</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS3/">CSS3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-2017/11/CSS3-动画的使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2017/11/CSS3-动画的使用.html" class="article-date">
      <time datetime="2022-11-05T14:53:17.293Z" itemprop="datePublished">2022-11-05</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2017/11/CSS3-动画的使用.html">CSS3动画的使用方法</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="CSS3动画的使用方法"><a href="#CSS3动画的使用方法" class="headerlink" title="CSS3动画的使用方法"></a>CSS3动画的使用方法</h1><h2 id="形状变换-—-高级动画基础"><a href="#形状变换-—-高级动画基础" class="headerlink" title="形状变换  —   高级动画基础"></a>形状变换  —   高级动画基础</h2><h3 id="transform-–-可以实现元素的形状、角度、位置等的变化。"><a href="#transform-–-可以实现元素的形状、角度、位置等的变化。" class="headerlink" title="transform – 可以实现元素的形状、角度、位置等的变化。"></a>transform – 可以实现元素的形状、角度、位置等的变化。</h3><p>他的值有很多种：</p>
<h4 id="旋转："><a href="#旋转：" class="headerlink" title="旋转："></a>旋转：</h4><p>rotate(); 以x/y/z为轴进行旋转，默认为z<br>rotatex(), rotatey(), rotatez(), rotate3d(x, y, z, angle) x, y, z —&gt;</p>
<h4 id="缩放："><a href="#缩放：" class="headerlink" title="缩放："></a>缩放：</h4><p>scale(); 以x/y为轴进行缩放<br>scale(x, y) 接受两个值，如果第二参数未提供，则第二个参数使用第一个参数的值<br>scalex(),scaley() 值是数字表示倍数，不加任何单位<br>scalez()<br>scale3d()  scale3d(sx,sy,sz)</p>
<h4 id="扭曲："><a href="#扭曲：" class="headerlink" title="扭曲："></a>扭曲：</h4><p>skew(); 对元素进行倾斜扭曲<br>skew(x, y);接受两个值，第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0<br>skewx(), skewy()</p>
<h4 id="平移："><a href="#平移：" class="headerlink" title="平移："></a>平移：</h4><p>translate(); 可以移动距离,相对于自身位置。<br>translate(x, [y])<br>translatex(),translatey(),translatez(),translate3d(x, y, z)  正规的写法是XYZ都应该是大写的。括号里面的值可以是像素(px, %)  当不知道元素自身的宽高是应该用这个百分比法来进行居中处理(-50%,-50%);</p>
<h4 id="transform-origin-变换原点"><a href="#transform-origin-变换原点" class="headerlink" title="transform-origin 变换原点"></a>transform-origin 变换原点</h4><p>任何一个元素都有一个中心点，<br>默认情况下，其中心点是居于元素x轴和y轴的50%处。配合缩放的方法来使用，根据中心点的位置进行缩放。</p>
<h4 id="transition-过渡动画"><a href="#transition-过渡动画" class="headerlink" title="transition  过渡动画"></a>transition  过渡动画</h4><p>transition  属性是css3的一个复合属性，主要包括一下几个子属性<br>transition-property:指定过渡或动态模拟的css属性<br>transition-duration:指定过渡所需要的时间<br>transition-timing-function:指定过渡函数<br>transition-delay:指定开始出现的延迟时间</p>
<p>transition  过渡动画可以参与过渡的属性</p>
<h4 id="animation-–-动画铺垫"><a href="#animation-–-动画铺垫" class="headerlink" title="animation – 动画铺垫"></a>animation – 动画铺垫</h4><p>动画关键帧<br>@keyframes </p>
<p>animation 动画会按照keyframes 关键帧里面指定的帧状态而过渡执行。<br>0% - 100% 代表动画的时间过渡<br>@keyframes demoMove{<br>0%{ background-color:red;}<br>10%{ background-color:green;}<br>20%{ background-color:white;}<br>50%{ width:200px;}<br>100%{ height:200px;}</p>
<p>animation 属性为css3的复合属性，主要包括以下子属性<br>animation-name:  此属性为执行动画的 keyframe 名<br>animation-duration:此属性为动画执行的时间<br>animation-timing-function:指定过渡函数速率<br>animation-delay: 执行延迟时间<br>animation-direction: normal/reverse/alternate/alternate-reverse;<br>animation-iteration-count:infinite/number;<br>animation-fill-mode:forwards/backwards/both/none;</p>
<p>animation-iteration-count:<br>            属性主要用来定义动画的播放次数。<br>            n 播放次数<br>            infinite 无限次<br>       animation-direction:<br>            属性主要用来设置动画播放方向<br>            normal  默认值。动画按正常播放。    测试 »<br>            reverse 动画反向播放。 测试 »<br>            alternate   动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。    测试 »<br>            alternate-reverse   动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。    测试 »</p>
<p>animation-play-state:<br>            属性主要用来控制元素动画的播放状态。<br>            running 播放<br>            paused  暂停<br>       animation-fill-mode:<br>            属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：<br>            none:<br>                默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时，动画会反转到初始帧处</p>
<pre><code>forwards:
    表示动画在结束后继续应用最后的关键帧的位置
backwards:
    会在向元素应用动画样式时迅速应用动画的初始帧
both:
    元素动画同时具有forwards和backwards效果
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/必备知识/">必备知识</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS3/">CSS3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2022 Dexinser
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>