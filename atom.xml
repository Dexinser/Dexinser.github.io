<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>To die or not to die, this is a question~</title>
  
  <subtitle>不想成为架构师的程序员不是一个好的程序员~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dexinser.github.io/"/>
  <updated>2022-11-14T17:19:55.763Z</updated>
  <id>https://dexinser.github.io/</id>
  
  <author>
    <name>Dexinser</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript原型链</title>
    <link href="https://dexinser.github.io/2021/2021.08.21-Javascript%E5%8E%9F%E5%9E%8B%E9%93%BE.html"/>
    <id>https://dexinser.github.io/2021/2021.08.21-Javascript原型链.html</id>
    <published>2021-08-20T16:00:00.000Z</published>
    <updated>2022-11-14T17:19:55.763Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Javascript原型链：</strong> <Excerpt in index | 首页摘要></p><p>Javascript 中的“一切皆对象”。接下来那我们直接进入正题吧，今天就来讲一讲Javascript中的原型链的关系吧。说到原型，首先我们需要知道原型的基本规则。<br><a id="more"></a></p><The rest of contents | 余下全文><p>Javascript 中的“一切皆对象”。接下来那我们直接进入正题吧，今天就来讲一讲Javascript中的原型链的关系吧。说到原型，首先我们需要知道原型的基本规则。<br><!-- more --></p><The rest of contents | 余下全文><h1 id="Javascript-中的“一切皆对象”"><a href="#Javascript-中的“一切皆对象”" class="headerlink" title="Javascript 中的“一切皆对象”"></a>Javascript 中的“一切皆对象”</h1><p>接触 JavaScript 的前端开发应该都听过这句话</p><blockquote><p>一切皆对象</p></blockquote><p><strong>从原型链这里来看这句话的话，也可以理解为，所有有原型链的没有手动变更过原型的数据最终都会找到继承于 Object.prototype 这个对象中来。</strong></p><p>那我们直接进入正题吧，今天就来讲一讲Javascript中的原型链的关系吧。说到原型，首先我们需要知道原型的基本规则。</p><h1 id="原型基本规则"><a href="#原型基本规则" class="headerlink" title="原型基本规则"></a>原型基本规则</h1><ol><li><strong>对象</strong> 有 <strong><strong>proto</strong></strong> 属性，<strong>函数</strong> 有 <strong>prototype</strong> 属性。</li><li>所有 <strong>对象</strong> 都是由 <strong>函数</strong> 生成的。</li><li>生成 <strong>对象</strong> 时，<strong>对象</strong> 的 <strong><strong>proto</strong></strong> 属性指向 <strong>函数</strong> 的 <strong>prototype</strong> 属性。</li></ol><p>在没有手动修改 <strong><strong>proto</strong></strong> 属性的指向时，以上三条便是JavaScript默认原型链的指向逻辑。</p><h2 id="下面我们来从最一般的情况开始，逐步深入的详细解释一下："><a href="#下面我们来从最一般的情况开始，逐步深入的详细解释一下：" class="headerlink" title="下面我们来从最一般的情况开始，逐步深入的详细解释一下："></a>下面我们来从最一般的情况开始，逐步深入的详细解释一下：</h2><h3 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">创建空对象时，实际上我们是用<span class="built_in">Object</span>函数来生成对象的：</span><br><span class="line">&gt;<span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">&gt;o.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">我们也可以显式的使用<span class="built_in">Object</span>函数来创建对象：</span><br><span class="line">&gt;<span class="keyword">var</span> o = <span class="built_in">Object</span>()</span><br><span class="line">o.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">当我们使用函数来创建自定义的对象时，上面的规则同样适用：</span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">MyObj</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&gt;<span class="keyword">typeof</span> MyObj</span><br><span class="line"><span class="string">"function"</span></span><br><span class="line">&gt;<span class="keyword">var</span> mo = <span class="keyword">new</span> MyObj()</span><br><span class="line">&gt;mo.__proto__ === MyObj.prototype</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>既然JavaScript里“一切皆对象”，那函数自然也是对象的一种。对于函数作为对象来说，上面的规则同样适用：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数对象都是由<span class="function"><span class="keyword">Function</span>函数生成的：</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(</span>)&#123;&#125;</span><br><span class="line">&gt;fn.__proto__ === <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>我们可以看到，把函数当做对象时，生成它的函数就是 Function函数。那Function函数本身呢？同样适用！<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span>函数本身作为对象时，生成它的函数是他自身！</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">Function</span>.<span class="title">__proto__</span> =</span>== <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>同样我们知道，Object函数也是一个函数对象，那么它是否符合上面的规则呢？当然！<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>函数既然是函数，那生成它的函数自然是<span class="built_in">Function</span>函数咯：</span><br><span class="line">&gt;<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><h3 id="prototype是谁？"><a href="#prototype是谁？" class="headerlink" title="prototype是谁？"></a>prototype是谁？</h3><p>好了，现在我们知道，对象的<strong>proto</strong>属性是从生成它的函数的prototype那里得来的，那我们不禁要问，函数的prototype又是谁？<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一般函数默认的prototype是系统自动生成的一个对象：</span><br><span class="line">&gt;<span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">()</span><span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function">&gt;<span class="title">typeof</span> <span class="title">fn</span>.<span class="title">prototype</span></span></span><br><span class="line"><span class="function">"<span class="title">object</span>"</span></span><br><span class="line"><span class="function">&gt;<span class="title">fn</span>.<span class="title">prototype</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;constructor: ƒ&#125;</span></span></span><br><span class="line"><span class="function">    <span class="title">constructor</span>:</span> ƒ fn()</span><br><span class="line">    __proto__: <span class="keyword">Object</span></span><br><span class="line"></span><br><span class="line">&gt;fn.prototype<span class="function">.<span class="keyword">constructor</span> === <span class="title">fn</span></span></span><br><span class="line"><span class="function"><span class="title">true</span></span></span><br><span class="line"><span class="function">&gt;<span class="title">fn</span>.<span class="title">prototype</span>.__<span class="title">proto__</span> === <span class="title">Object</span>.<span class="title">prototype</span></span></span><br><span class="line"><span class="function"><span class="title">true</span></span></span><br></pre></td></tr></table></figure></p><p>一般函数默认的prototype是一个类型为”object”的对象，它有两个属性：constructor和 <strong>proto</strong>。其中constructor属性指向这个函数自身，<strong>proto</strong>属性指向Object.prototype，这说明一般函数的prototype属性是由Object函数生成的。</p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>前面我们特别强调了是一般函数，那不一般的函数是谁呢？当然是Object函数和Function函数！<br>先来看Object.prototype:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">typeof</span> Object.prototype</span><br><span class="line"><span class="string">"object"</span></span><br><span class="line">&gt;Object.prototype</span><br><span class="line">&#123;constructor: ƒ, <span class="variable">__defineGetter__</span>: ƒ, <span class="variable">__defineSetter__</span>: ƒ, hasOwnProperty: ƒ, <span class="variable">__lookupGetter__</span>: ƒ, …&#125;</span><br><span class="line">    constructor: ƒ Object()</span><br><span class="line">    hasOwnProperty: ƒ hasOwnProperty()</span><br><span class="line">    isPrototypeOf: ƒ isPrototypeOf()</span><br><span class="line">    propertyIsEnumerable: ƒ propertyIsEnumerable()</span><br><span class="line">    toLocaleString: ƒ toLocaleString()</span><br><span class="line">    <span class="built_in">toString</span>: ƒ <span class="built_in">toString</span>()</span><br><span class="line">    valueOf: ƒ valueOf()</span><br><span class="line">    <span class="variable">__defineGetter__</span>: ƒ <span class="variable">__defineGetter__</span>()</span><br><span class="line">    <span class="variable">__defineSetter__</span>: ƒ <span class="variable">__defineSetter__</span>()</span><br><span class="line">    <span class="variable">__lookupGetter__</span>: ƒ <span class="variable">__lookupGetter__</span>()</span><br><span class="line">    <span class="variable">__lookupSetter__</span>: ƒ <span class="variable">__lookupSetter__</span>()</span><br><span class="line">    get <span class="variable">__proto__</span>: ƒ <span class="variable">__proto__</span>()</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">__proto__</span>: ƒ <span class="variable">__proto__</span>()</span><br></pre></td></tr></table></figure></p><p>可以看到Object函数的prototype属性也是一个类型为”object”的对象，但和一般函数的默认prototype属性不一样的是，它多了一大堆方法，这些方法都是JavaScript对象的系统默认方法。<br>再仔细看，好像少了什么，对了，Object函数的prototype属性里没有<strong>proto</strong>属性，我们试着把它的<strong>proto</strong>属性打出来看看：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-tag">Object</span><span class="selector-class">.prototype</span><span class="selector-class">.__proto__</span></span><br><span class="line"><span class="selector-tag">null</span></span><br></pre></td></tr></table></figure></p><p>这就是Object函数特殊情况了：Object.prototype.<strong>proto</strong> === null，我们知道，这就是JavaScript原型链的终点了。<br>为什么要这样设定呢？<br>typeof Object.prototype === “object”，说明它是一个Object对象，如果它由Object函数生成，于是按照我们上面的通用规则，就该是Object.prototype.<strong>proto</strong> === Object.prototype。<br>啊哈，问题出现了，Object.prototype.<strong>proto</strong>属性指向了它自身，这样以<strong>proto</strong>属性构成的原型链就再也没有终点了！所以为了让原型链有终点，在原型链的最顶端，JavaScript规定了Object.prototype.<strong>proto</strong> === null。</p><p>好，现在再来看Function函数吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="string">"function"</span></span><br></pre></td></tr></table></figure></p><p>一上来就不走寻常路，Function函数的prototype属性是一个”function”类型的对象，而不像其他函数是类型为”object”的对象。那是个什么样的函数呢？<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span></span><br><span class="line"><span class="function">ƒ <span class="params">()</span> </span>&#123; [native code] &#125;</span><br></pre></td></tr></table></figure></p><p>函数内部是[native code]，也就是系统编译好的二进制代码函数，这就暂时没法深究了。现在让我们来看看我们最关心的<strong>proto</strong>属性：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;Function.prototype.<span class="variable">__proto__</span></span><br><span class="line">&#123;constructor: ƒ, <span class="variable">__defineGetter__</span>: ƒ, <span class="variable">__defineSetter__</span>: ƒ, hasOwnProperty: ƒ, <span class="variable">__lookupGetter__</span>: ƒ, …&#125;</span><br><span class="line">    constructor: ƒ Object()</span><br><span class="line">    hasOwnProperty: ƒ hasOwnProperty()</span><br><span class="line">    isPrototypeOf: ƒ isPrototypeOf()</span><br><span class="line">    propertyIsEnumerable: ƒ propertyIsEnumerable()</span><br><span class="line">    toLocaleString: ƒ toLocaleString()</span><br><span class="line">    <span class="built_in">toString</span>: ƒ <span class="built_in">toString</span>()</span><br><span class="line">    valueOf: ƒ valueOf()</span><br><span class="line">    <span class="variable">__defineGetter__</span>: ƒ <span class="variable">__defineGetter__</span>()</span><br><span class="line">    <span class="variable">__defineSetter__</span>: ƒ <span class="variable">__defineSetter__</span>()</span><br><span class="line">    <span class="variable">__lookupGetter__</span>: ƒ <span class="variable">__lookupGetter__</span>()</span><br><span class="line">    <span class="variable">__lookupSetter__</span>: ƒ <span class="variable">__lookupSetter__</span>()</span><br><span class="line">    get <span class="variable">__proto__</span>: ƒ <span class="variable">__proto__</span>()</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">__proto__</span>: ƒ <span class="variable">__proto__</span>()</span><br></pre></td></tr></table></figure><p>怎么有种似曾相识的感觉呢？看起来很像是Object.prototype，让我们来试试：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><p>果然就是它！<br>按照我们最开始提出的通用规则，一个”function”类型的对象，应该是由Function函数生成的，那它的prototype属性应该指向Function.prototype，也就是Function.prototype.<strong>proto</strong> === Function.prototype。和Object函数同样的问题出现了：循环引用。所以JavaScript规定Function.prototype.<strong>proto</strong> === Object.prototype，这样既避免了出现循环引用，又让<strong>proto</strong>构成的原型链指向了唯一的终点：Object.prototype.<strong>proto</strong> === null。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们从最一般的对象一直追溯到了Object函数和Function函数，并找在原型链的顶端发现了两个例外情况，也知道了这两个例外个规定是为了让<strong>proto</strong>构成的原型链存在一个唯一的终点。</p><p>现在我们再来看这张JavaScript原型链的图，是不是一目了然了呢？</p><p><img src="https://s3.bmp.ovh/imgs/2021/08/b5f5a7f8d04b3430.webp" alt="prototype" title="原型链"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Javascript原型链：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;Javascript 中的“一切皆对象”。接下来那我们直接进入正题吧，今天就来讲一讲Javascript中的原型链的关系吧。说到原型，首先我们需要知道原型的基本规则。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://dexinser.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>The Tipping Point</title>
    <link href="https://dexinser.github.io/2018/2018.01.28%20The%20Tipping%20Point.html"/>
    <id>https://dexinser.github.io/2018/2018.01.28 The Tipping Point.html</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2022-11-14T17:19:29.303Z</updated>
    
    <content type="html"><![CDATA[<p><strong> The Tipping Point：</strong> <Excerpt in index | 首页摘要></p><p>《引爆点》这本书是格拉德威尔在2000年出版的。一经出版就火爆全球，书中介绍的“引爆点”和流行三法则，已经成为当下的商业理论新经典。<br><a id="more"></a></p><The rest of contents | 余下全文><p>《引爆点》这本书是格拉德威尔在2000年出版的。一经出版就火爆全球，书中介绍的“引爆点”和流行三法则，已经成为当下的商业理论新经典。<br>思考是这本书的主旋律，作者对生活中的一些常见现象，并没有去听从各种专家所说的，不能让人信服的观点，例如：经济学家所说的是由于经济的好转所以就是年代的纽约市犯罪行为的减少；犯罪学家所说的是由于纽约市警察局的警力部署的加强所导致的犯罪行为的减少等等。作者深入思考了这些社会现象之后，认为那些专家所说的理由并不能成为形成这种现象的原因，进而自己来进行寻找和探索，由此而诞生的这本书，进而解读我们社会中的一些流行事件的原因，真的是让我们这些读者打开思想的大门，教给我们各种新奇规律的同时，也教给了我们思考问题的方式和方法。<br>书中的很多著名的专家学者在开篇点评这本书，看完这本书之后重新看这些评语，真是另一种感受：格拉德威尔不愧为2005年《时代》杂志评为世界最有影响力的100人之一，普通人的回答，很少能超出几个大脑早已作出的界定，如：亚当斯密的“看不见的手”、凯恩斯的“调控”、哈耶克的“自发生成秩序”、马克思的辩证唯物主义和历史唯物主义、弗洛伊德的心理分析…而变革者则提出理解世界的新方法：凯恩斯对亚当斯密进行修补；弗洛伊德另辟蹊经；毕加索挑战马蒂斯；爱因斯坦修订牛顿为大自然的“立法”，德鲁克对组织进行研究，提出“知识工人”与受雇阶层的理论。本质上，格拉德威尔与上面提到的为人是一类人，也是一个有新意的变革者。书中开创性的提出了很多名词：流行三法则（个别人物法则[联系员、内行和推销员—保罗·里维尔骑马夜行]、附着力法则[影响事情的主要原因跟我们所想的不一样，往往是很微小的因素所形成的—金盒子广告和打破伤风疫苗、芝麻街和蓝狗线索]、环境威力法则[人们往往会在心里对一个人有一种印象，而往往忽视了环境的不同造成的影响因素；而在事实与我们印象中的不同时我们又会找一个我们自己所能够理解的方式来解释，而保留对一个人印象的唯一性；思维定势中的我们往往又会夸大一些环境因素对我们的影响，例如：家庭因素对我们的影响等等，其实并没有那么大的影响—流言、破窗理论、地铁涂鸦、地铁逃票…]）</p><p>引爆点教给了我们什么道理？就像作者总结的一样总共有三个。</p><h1 id="集中有限的力量，全力以赴。"><a href="#集中有限的力量，全力以赴。" class="headerlink" title="集中有限的力量，全力以赴。"></a>集中有限的力量，全力以赴。</h1><p>我们大多数人做事，一般都是差不多的思维模式，相同的老办法。而往往这种老方法有时候并不是最优的，这种方法可能会包含着太多的浪费我们有限的资源的情况。思维定式之下，我们很难跳出这种限制，而格拉德威尔的这本书中就教给了我们很多方法，去找出事情的引爆点，往往就能付出最小的代价做成很多事情。美国独立战争时期，保罗·里维尔骑马夜行是成功的，但是另一个方向出发的威廉·戴维斯却是失败的，他没有成为历史上有名的人物…取巧之计用在这儿挺合适的，在编程中我们想要成长我们必须要取巧，各种自动化工具的使用，让电脑代替我们去处理重复繁琐的事情；在生活中取巧是我们做事情之前先要想到这件事情成功的引爆点在哪儿，尽量用最少的资源完成事情，不加选择地付出努力并非总是可行的，我们要尽可能的找到到达终点的捷径，以达到事半功倍的效果。</p><h1 id="世界并非是我们一厢情愿的直觉中的世界"><a href="#世界并非是我们一厢情愿的直觉中的世界" class="headerlink" title="世界并非是我们一厢情愿的直觉中的世界"></a>世界并非是我们一厢情愿的直觉中的世界</h1><p>我们总是在杂乱与黑暗之中行事，所以造成了很多的不必要的步骤。我们所认知的范畴限制了我们所看待世界的方式和误解我们所接触到的超出我们理解范围的事情。以抽象方式被表述成形象的社会问题，我们解决起来将会毫无困难。人类思维的特殊之处，在于我们能很好的处理同类之间复杂的关系。我们遇到问题的第一想法是先看一下我们的大脑中有没有储存以前类似的相关问题，类比之前的类似问题来进行处理现在所遇到的问题，但是我们又往往会忽略当下的条件下的不同，或是局限与我们知识储备的不足，处理当下的事情进而使用了错误的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; The Tipping Point：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;《引爆点》这本书是格拉德威尔在2000年出版的。一经出版就火爆全球，书中介绍的“引爆点”和流行三法则，已经成为当下的商业理论新经典。&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://dexinser.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="认知提升" scheme="https://dexinser.github.io/tags/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>磁盘格式</title>
    <link href="https://dexinser.github.io/2018/2018.01.21%20%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F.html"/>
    <id>https://dexinser.github.io/2018/2018.01.21 磁盘格式.html</id>
    <published>2018-01-20T16:00:00.000Z</published>
    <updated>2022-11-14T17:19:23.758Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 磁盘格式：</strong> <Excerpt in index | 首页摘要></p><p>好久没更博客了，虽然没什么人看，但是作为练习自己写作能力的锻炼和提升，也不能荒废我的博客更新哈~<br><a id="more"></a></p><The rest of contents | 余下全文><p>好久没更博客了，虽然没什么人看，但是作为练习自己写作能力的锻炼和提升，也不能荒废我的博客更新哈~<br>说一下我最近的个人动态吧~ 现在学校放假有两个星期了，学校一放假就跑到实习公司来实习了，一进公司报到当天就给我配置了2015年的mac pro顶配版，不得不说真是开心哈~而且是2017年产的新开封的哦~不要羡慕哦~哈哈哈，你们以后工作也会有的。然后新进公司第一周就一直在熟悉mac本的一些基础操作，没办法，谁让我没用过这种高大上的苹果笔记本呢。我是刚把Windows系统的笔记本用到稍微熟练一点儿，就让我接触mac真是有点儿不熟悉呢，不过经过一周的操作训练，越来越觉的mac的人性化，怪不得办公的大公司的白领啦、管理者啦、领导啦什么的，都喜欢用苹果本办公呢，真的比Windows好用多了，当然了，这只是我个人的一些浅显小想法，大家不同意就当我没说，我的人生阅历还是很少，不能确定说的对哈~</p><p>好了，接下来就来说一下写这篇博客的由来吧~换上了mac本之后，看到了mac自带的时间机器，感觉好高大上啊，可以自动保存快照，想什么时候回退到哪儿都行，真是太强大的一个功能了。虽然这个说是不占用mac上剩余的内存，不过我还是担心影响我的笔记本日常所使用的性能，万一影响我的使用体验都不好，在说了我也有一个自己的硬盘，为什么不用我自己的硬盘当作是Time Machien的保存磁盘呢；想到就去做了，第二天就把我的磁盘带过来了，兴致勃勃的插上去却让我失望了，居然是只能读的权限，然后我才知道Windows下的保存文件格式与mac下的保存文件格式是不同的。啊啊啊，要想用做mac的时间机器的御用磁盘必须先把磁盘数据全部格式化了，但是我的磁盘上还有好多我都珍贵的资源呢，怎么能删除掉呢，所以只能先把数据保存到其他的地方，到时候把磁盘的格式改回来在存进去。然后就又把磁盘带回去了，把数据拷贝到了我的Windows电脑上，然后在mac上把磁盘格式化了，终于能用作备份磁盘了，真是好不容易啊。但是这样的话又变成了磁盘只能在mac上用了，所以我索性把我的1T硬盘，分成3个区，一个单独的用作mac数据备份区，另两个一个用作Windows存放数据区，另一个用作mac存放数据区。这样总算大功告成了吧，谁知道原来我把Windows上使用的存放数据格式给改成了Fat32格式的，不是我想要的NTFS格式的，但是这个时候我已经把原先的数据都已经导回来了，实在不想再折腾了，啊啊啊，好伤心啊！接下来就让我介绍一下他俩的区别吧~</p><h1 id="FAT32与NTFS的区别"><a href="#FAT32与NTFS的区别" class="headerlink" title="FAT32与NTFS的区别"></a>FAT32与NTFS的区别</h1><p>在推出FAT32文件系统之前，通常PC机使用的文件系统是FAT16。像基于MS-DOS，Win 95等系统都采用了FAT16文件系统。在Win 9X下，FAT16支持的分区最大为2GB。我们知道计算机将信息保存在硬盘上称为“簇”的区域内。使用的簇越小，保存信息的效率就越高。在FAT16的情况下，分区越大簇就相应的要增大，存储效率就越低，势必造成存储空间的浪费。并且随着计算机硬件和应用的不断提高，FAT16文件系统已不能很好地适应系统的要求。在这种情况下，推出了增强的文件系统FAT32。同FAT16相比，FAT32主要具有以下特点：</p><ol><li>同FAT16相比FAT32最大的优点是可以支持的磁盘大小达到2TB（2047GB），但是不能支持小于512MB的分区。基于FAT32的Win 2000可以支持分区最大为32GB；而基于 FAT16的Win 2000支持的分区最大为4GB。</li><li>由于采用了更小的簇，FAT32文件系统可以更有效率地保存信息。如两个分区大小都为2GB，一个分区采用了FAT16文件系统，另一个分区采用了FAT32文件系统。采用FAT16的分区的簇大小为32KB，而FAT32分区的簇只有4KB的大小。这样FAT32就比FAT16的存储效率要高很多，通常情况下可以提高15%。</li><li>FAT32文件系统可以重新定位根目录和使用FAT的备份副本。另外FAT32分区的启动记录被包含在一个含有关键数据的结构中，减少了计算机系统崩溃的可能性。<br>NTFS文件系统<br>NTFS文件系统是一个基于安全性的文件系统，是Windows NT所采用的独特的文件系统结构，它是建立在保护文件和目录数据基础上，同时照顾节省存储资源、减少磁盘占用量的一种先进的文件系统。使用非常广泛的Windows NT 4.0采用的就是NTFS 4.0文件系统，相信它所带来的强大的系统安全性一定给广大用户留下了深刻的印象。Win 2000采用了更新版本的NTFS文件系统??NTFS 5.0，它的推出使得用户不但可以像Win 9X那样方便快捷地操作和管理计算机，同时也可享受到NTFS所带来的系统安全性。<br>NTFS 5.0的特点主要体现在以下几个方面：</li><li>NTFS可以支持的分区(如果采用动态磁盘则称为卷)大小可以达到2TB。而Win 2000中的FAT32支持分区的大小最大为32GB。</li><li>NTFS是一个可恢复的文件系统。在NTFS分区上用户很少需要运行磁盘修复程序。NTFS通过使用标准的事物处理日志和恢复技术来保证分区的一致性。发生系统失败事件时，NTFS使用日志文件和检查点信息自动恢复文件系统的一致性。</li><li>NTFS支持对分区、文件夹和文件的压缩。任何基于Windows的应用程序对NTFS分区上的压缩文件进行读写时不需要事先由其他程序进行解压缩，当对文件进行读取时,文件将自动进行解压缩；文件关闭或保存时会自动对文件进行压缩。</li><li>NTFS采用了更小的簇,可以更有效率地管理磁盘空间。在Win 2000的FAT32文件系统的情况下,分区大小在2GB～8GB时簇的大小为4KB；分区大小在8GB～16GB时簇的大小为8KB；分区大小在16GB～32GB时,簇的大小则达到了16KB。而Win 2000的NTFS文件系统，当分区的大小在2GB以下时,簇的大小都比相应的FAT32簇小;当分区的大小在2GB以上时(2GB～2TB),簇的大小都为4KB。相比之下，NTFS可以比FAT32更有效地管理磁盘空间，最大限度地避免了磁盘空间的浪费。</li><li>在NTFS分区上,可以为共享资源、文件夹以及文件设置访问许可权限。许可的设置包括两方面的内容：一是允许哪些组或用户对文件夹、文件和共享资源进行访问；二是获得访问许可的组或用户可以进行什么级别的访问。访问许可权限的设置不但适用于本地计算机的用户,同样也应用于通过网络的共享文件夹对文件进行访问的网络用户。与FAT32文件系统下对文件夹或文件进行访问相比，安全性要高得多。另外,在采用NTFS格式的Win 2000中,应用审核策略可以对文件夹、文件以及活动目录对象进行审核，审核结果记录在安全日志中，通过安全日志就可以查看哪些组或用户对文件夹、文件或活动目录对象进行了什么级别的操作，从而发现系统可能面临的非法访问,通过采取相应的措施，将这种安全隐患减到最低。这些在FAT32文件系统下,是不能实现的。</li><li>在Win 2000的NTFS文件系统下可以进行磁盘配额管理。磁盘配额就是管理员可以为用户所能使用的磁盘空间进行配额限制，每一用户只能使用最大配额范围内的磁盘空间。设置磁盘配额后，可以对每一个用户的磁盘使用情况进行跟踪和控制，通过监测可以标识出超过配额报警阈值和配额限制的用户，从而采取相应的措施。磁盘配额管理功能的提供，使得管理员可以方便合理地为用户分配存储资源，避免由于磁盘空间使用的失控可能造成的系统崩溃，提高了系统的安全性。</li><li>NTFS使用一个“变更”日志来跟踪记录文件所发生的变更。</li></ol><h1 id="小提示-选取FAT32和NTFS的建议"><a href="#小提示-选取FAT32和NTFS的建议" class="headerlink" title="小提示(选取FAT32和NTFS的建议)"></a>小提示(选取FAT32和NTFS的建议)</h1><p>在系统的安全性方面，NTFS文件系统具有很多FAT32文件系统所不具备的特点，而且基于NTFS的Win 2000运行要快于基于FAT32的Win 2000；而在与Win 9X的兼容性方面，FAT32优于NTFS。所以在决定Win 2000中采用什么样的文件系统时应从以下几点出发：</p><ol><li>计算机是单一的Win 2000系统，还是采用多启动的Win 2000系统；</li><li>本地安装的磁盘的个数和容量；</li><li>是否有安全性方面的考虑等。<br>基于以上的考虑，如果要在Win 2000中使用大于32GB的分区的话，那么只能选择NTFS格式。如果计算机作为单机使用，不需要考虑安全性方面的问题，更多地注重与Win 9X的兼容性，那么FAT32是最好的选择。如果计算机作为网络工作站或更多的追求系统的安全性，而且可以在单一的Win 2000模式下运行，强烈建议所有的分区都采用NTFS格式；如果要兼容以前的应用，需要安装Win 9X或其它的操作系统，建议做成多启动系统，这就需要两个以上的分区，一个分区采用NTFS格式，另外的分区采用FAT32格式，同时为了获得最快的运行速度建议将Win 2000的系统文件放置在NTFS分区上，其它的个人文件则放置在FAT32分区中。<br>回答字数10000字以内<br>参考资料：<br>如果您的回答是从其他地方引用，请表明出处。</li></ol><hr><h1 id="FAT分区与NTFS分区有什么区别？"><a href="#FAT分区与NTFS分区有什么区别？" class="headerlink" title="FAT分区与NTFS分区有什么区别？"></a>FAT分区与NTFS分区有什么区别？</h1><h2 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h2><p>在选择 NTFS 时可以使用的功能有：<br>Active Directory，可用来方便地查看和控制网络资源。<br>域，它是 Active Directory 的一部分，在简化管理的同时，依然可以使用域来调整安全选项。域控制器需要 NTFS 文件系统。<br>文件加密，它极大地增强了安全性。<br>可以对单个文件设置权限，而不仅仅是对文件夹进行设置。<br>稀疏文件，这些是由应用程序创建的非常大的文件，以这种方式创建的文件只受磁盘空间的限制。也就是，NTFS 只为写入的文件部分分配磁盘空间。<br>远程存储，通过使可移动媒体（如磁带）更易访问，从而扩展了硬盘空间。<br>磁盘活动恢复记录，可帮助您在断电或发生其他系统问题时，尽快地还原信息。<br>磁盘配额，可用来监视和控制单个用户使用的磁盘空间量。<br>可更好地支持大驱动器，NTFS 支持的最大驱动容量比 FAT 支持的容量大得多，但随着驱动器容量得增大，NTFS 的性能并不随之降低，而 FAT 的性能却急速下降。<br>这只是最新版 NTFS 的部分功能列表。有关新功能的详细信息，请参阅 Windows 2000 Advanced Server 的新特性。<br>安装程序可以方便地将分区转换为新版的 NTFS，即使该分区以前使用的是 FAT 或 FAT32 文件系统，这种转换可保持文件的完整性（与格式化分区不同）。安装程序通过从检查现有的文件系统开始运行。如果文件系统是 NTFS，转换会自动发生。如果是 FAT 或 FAT32，安装程序可让您选择是否要将它们转换为 NTFS。如果不想保留文件，且有一个 FAT 或 FAT32 分区，建议使用 NTFS 格式化该分区，而不是转换 FAT 或 FAT32 文件系统。格式化分区会删除该分区上所有的数据，但使用 NTFS 格式化的分区与从 FAT 或 FAT32 转换来的分区相比，磁盘碎片较少，且性能更快。<br>但是使用 NTFS 依然有缺点，不论该分区是用 NTFS 格式化还是从以前的文件系统转换而来。在安装完成之后，也可以使用 Convert.exe 转换分区的文件系统。有关 Convert.exe 的详细信息，在结束安装之后，单击“开始”，再单击“运行”，键入 cmd 并按回车键键即可查阅它的信息。在命令窗口，键入 help convert，然后按回车键。FAT 和 FAT32<br>FAT 和 FAT32 是可选的文件系统选项。如果必须将计算机安装为有时使用以前的操作系统（有时使用 Windows 2000），则将要使用这些文件系统。其他信息，请参阅：<br>决定计算机是否包含多个操作系统<br>多个操作系统和文件系统的兼容性<br>包含 Windows NT 4.0 和 Windows 2000 Advanced Server 的计算机<br>在 NTFS、FAT 和 FAT32 间选择<br>有关 FAT 和 FAT32 之间区别的详细信息，请参阅在 NTFS、FAT 和 FAT32 间选择中的表格。如果要在 FAT 和 FAT32 之间做出选择，基本的标准是安装分区的大小。如果分区容量是 2 GB 或更大，应使用 FAT32 而不是 FAT 分区。<br>注意<br>Windows 2000 支持任意大小的由 Windows 95 或 Windows 98 创建的 AT32 卷。但是，Windows 2000 格式化的 FAT32 卷最大容量只能达到 32 GB。NTFS 是更好的选择，可应用在容量大于 32 GB 的卷上。<br>如果在安装过程中，选择使用 FAT 格式化分区，且该分区大于 2 GB，那么安装程序会自动用 FAT32 文件系统格式化。<br>在 NTFS、FAT 和 FAT32 间选择<br>可以为 Windows 2000 Advanced Server 计算机的磁盘分区选择下列之一的文件系统：NTFS、FAT 和 FAT32。NTFS 是推荐的文件系统。FAT 和 FAT32 彼此相似，但与 FAT 相比，FAT32 可用在容量较大的磁盘上。（最容易使用大磁盘的文件系统是 NTFS。）本节介绍的信息可帮助您比较这些文件系统，有关每种文件系统的其他信息，请参阅：<br>NTFS</p><p>##FAT 和 FAT32<br>NTFS 与 FAT 和 FAT32 相比，它是最强大的文件系统。Windows 2000 Advanced Server 包括新版本的 NTFS，它支持各种新功能（包括 Active Directory），而域、用户帐户和其他重要的安全特性都需要 Active Directory 功能。<br>安装程序可以方便地将分区转换为新版的 NTFS，即使该分区以前使用的是 FAT 或 FAT32 文件系统，这种转换可保持文件的完整性（与格式化分区不同）。如果不想保留文件，且有一个 FAT 或 FAT32 分区，建议使用 NTFS 格式化该分区，而不是转换 FAT 或 FAT32 文件系统。格式化分区会删除该分区上所有的数据，但使用 NTFS 格式化的分区与从 FAT 或 FAT32 转换来的分区相比，磁盘碎片较少，且性能更快。<br>但是使用 NTFS 依然有缺点，不论该分区是用 NTFS 格式化还是从以前的文件系统转换而来。在安装完成之后，也可以使用 Convert.exe 转换分区的文件系统。有关 Convert.exe 的详细信息，在结束安装之后，单击“开始”，再单击“运行”，键入 cmd 并按回车键即可查阅它的信息。在命令窗口，键入 help convert，然后按回车键。<br>注意<br>只有通过选择 NTFS 作为您的文件系统，才能使用诸如 Active Directory 和基于域的安全性等重要功能。<br>有一种情况可能需要将 FAT 或 FAT32 选为您的文件系统。如果需要让计算机有时运行早期的操作系统，有时运行 Windows 2000，则需要将 FAT 或 FAT32 分区作为硬盘上的主（或启动）分区。这是因为早期的操作系统（只有一个例外），都无法访问使用最新版 NTFS 格式化的分区。例外是带有 Service Pack 4 或更高版本的 Windows NT 4.0，它可以访问使用最新版 NTFS 格式化的分区，但也有一些限制。Windows NT 4.0 无法访问那些用在 Windows NT 4.0 发布时，还没出现的 NTFS 功能存储的文件。详细信息，请参阅：<br>决定计算机是否包含多个操作系统<br>多个操作系统和文件系统的兼容性<br>但对于其他包含多个操作系统的情况，推荐的文件系统依然是 NTFS。<br>下面的表格介绍了每个文件系统与各种操作系统的兼容性。<br>NTFS FAT FAT32<br>运行 Windows 2000 的计算机可以访问 NTFS 分区上的文件。运行带有 Service Pack 4 或更高版本的 Windows NT 4.0计算机可能可以访问某些文件。其他操作系统则无法访问。 可以通过 MS-DOS、所有版本的 Windows、 Windows NT、 Windows 2000 和 OS/2 访问。 只能通过 Windows 95 OSR2、Windows 98 和 Windows 2000 访问。<br>下表比较了每个文件系统支持的磁盘和文件大小。<br>NTFS FAT FAT32<br>推荐最小的容量为 10 MB，<br>推荐实际最大的容量为 2 TB，并可支持更大的容量。<br>无法用在软盘上。<br>容量可从软盘大小到最大 4 GB。<br>不支持域。<br>容量从 512 MB 到 2 TB。<br>在 Windows 2000 中，可以格式化一个不超过 32 GB 的 FAT32 卷。<br>不支持域。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 磁盘格式：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;好久没更博客了，虽然没什么人看，但是作为练习自己写作能力的锻炼和提升，也不能荒废我的博客更新哈~&lt;br&gt;
    
    </summary>
    
      <category term="资源分享" scheme="https://dexinser.github.io/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="认知提升" scheme="https://dexinser.github.io/tags/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>那年那器那些事</title>
    <link href="https://dexinser.github.io/2017/12/What%20is%20the%20server.html"/>
    <id>https://dexinser.github.io/2017/12/What is the server.html</id>
    <published>2017-12-20T16:00:00.000Z</published>
    <updated>2022-11-14T16:40:03.609Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 那年那器那些事：</strong> <Excerpt in index | 首页摘要></p><p>hello，大家好，我叫服务器，承载了全世界互联网行业的光荣与梦想。最近，听说居然有人敢质疑我的权威，说我会不会宕机？明确告诉你，你可以骂我卡，但就是不让你看见我宕机！<br><a id="more"></a></p><The rest of contents | 余下全文><h2 id="服务器的自白"><a href="#服务器的自白" class="headerlink" title="服务器的自白"></a>服务器的自白</h2><blockquote><p>hello，大家好，我叫服务器，承载了全世界互联网行业的光荣与梦想。最近，听说居然有人敢质疑我的权威，说我会不会宕机？明确告诉你，你可以骂我卡，但就是不让你看见我宕机！</p></blockquote><h2 id="不是不想休息，而是不能宕机"><a href="#不是不想休息，而是不能宕机" class="headerlink" title="不是不想休息，而是不能宕机"></a>不是不想休息，而是不能宕机</h2><p>我们服务器是每一家互联网企业的支撑，如果支柱倒塌那会是怎样的灾难？所以我们不是不想休息，而是绝对不能宕机！服务器存在的目的是与家用电脑是完全不同的两种，家用电脑存在着不需要使用的时间点，而且这个时间点往往很长，因此家用电脑可以有很长的休眠时间。而服务器则不然，不同公司的服务器对使用时间段不同，这也就使得部分服务器根本不允许有休眠的时间。</p><h2 id="夜深人静，依然奋斗的服务器"><a href="#夜深人静，依然奋斗的服务器" class="headerlink" title="夜深人静，依然奋斗的服务器"></a>夜深人静，依然奋斗的服务器</h2><p>  根据数据显示，金融企业每次宕机的平均损失约为1000万美金，这还不让无法统计的无形资产损失。一些大型的网站通常会有登录的高峰阶段，例如12306的春运、电商平台的购物街、新型电子产品的发布等都会给服务器带来巨大的压力，宕机对企业就是灾难性的打击。</p><p><img src="https://outwcl4zh.bkt.clouddn.com/1.jpg" alt="f1"><br>               烧香拜佛难免服务器崩溃<br>  我们不是不想宕机，而是使命的存在让我们不能宕机。此外，又制定外部环境，过硬的自身素质和纯净的软件环境是保障我们稳定运行绝不宕机的条件。</p><h2 id="只有住的好，才能不显老"><a href="#只有住的好，才能不显老" class="headerlink" title="只有住的好，才能不显老"></a>只有住的好，才能不显老</h2><p>  我们的服务器的触觉比你们人类更加挑剔，工作时间比人类更长，因为良好的工作环境是必要条件。</p><h3 id="谷歌的数据中心"><a href="#谷歌的数据中心" class="headerlink" title="谷歌的数据中心"></a>谷歌的数据中心</h3><p>  在恒湿恒温准无尘的环境，没错，那就是我们最习惯的地方。我们这样挑剔的电子设备，工作环境必须常年保持在18℃到30℃之间，温度过高或者过低都将对我们的使用有所影响，加速我们的老化。空气的流通也是非常重要的，在我们所居住的地方，24小时空调是不能停。但是空调不能保障我们的体温的。每当我们服务器工作时间长了，浑身上下都会发热。因此大量的冷却水给我们进行贴身服务降温，保障服务器散热和机身温度的稳定。</p><h2 id="谷歌数据中心，不同颜色的冷却水"><a href="#谷歌数据中心，不同颜色的冷却水" class="headerlink" title="谷歌数据中心，不同颜色的冷却水"></a>谷歌数据中心，不同颜色的冷却水</h2><p>  我们的工作运行环境，要求至少达到准无尘标准。一般来讲，经过长期正常维护的服务器运行十年以上，主板上的积尘比用几个月的家用电脑服务器少。只有这样才能最大限度避免静电灰对服务器工作可靠性的影响。</p><h2 id="整洁、干净、无尘"><a href="#整洁、干净、无尘" class="headerlink" title="整洁、干净、无尘"></a>整洁、干净、无尘</h2><p>  更重要的是，我们的运维人员都非常专业，经常加班加点的对服务器的运行状况进行监测。以便于一旦发现任何问题，及时处理。否则，宕机也是在所难免。<br>  只为不宕机，硬件更专业，我们服务器的设计就是为了不宕机而出现的，这一点和家用电脑有着千差万别。<br>  没有完全不会坏的服务器，我们也会有故障。一次服务器在设计的时候做了大量的备份冗余，维护不会影响到正常工作。以谷歌的数据中心为例，大量的数据服务器都采取了即插即用模块化的方式设计。每个模块服务器有着自己的电源。如果某一模块发生故障，直接换上新的模块就可以，而不会影响到其他模块。</p><h2 id="模块化设计都有独立的电源"><a href="#模块化设计都有独立的电源" class="headerlink" title="模块化设计都有独立的电源"></a>模块化设计都有独立的电源</h2><p>  而且，服务器大多数设计为集群架构，即以双机或者多机热备。同时运行一个业务时，一台或者多台服务器的离线并不会对整体业务造成严重的影响。而这也是平时一些人在玩网游是会感觉卡的原因之一，很可能就是某台服务器偷懒启用了备用服务器的原因。</p><h2 id="模块维修，没想象的那么难"><a href="#模块维修，没想象的那么难" class="headerlink" title="模块维修，没想象的那么难"></a>模块维修，没想象的那么难</h2><p>  家用电脑可能会有生产商偷工减料节约成本，降低整体价格的现象存在。但是我们服务器领域却不会这样。CPU内置多种容错纠错机制；内存带有ECC校验芯片，数据干扰出错风险比非ECC内存低很多，采用优质方案是不宕机的关键所在。<br>  比家用服务器的商业级别的配件好太多，我们所有的零件都是工业级配件。而且从电子元件到电路板都经历了包括老化测试（高温高电压）、振动测试、高温高湿测试等几十项可靠性测试。经历了暴风雨的洗礼的我们却在温室中被供养，这就是常年不宕机的秘诀。</p><h3 id="服务器出厂要经过各种测试"><a href="#服务器出厂要经过各种测试" class="headerlink" title="服务器出厂要经过各种测试"></a>服务器出厂要经过各种测试</h3><h2 id="一生只做一件事，软件更纯粹"><a href="#一生只做一件事，软件更纯粹" class="headerlink" title="一生只做一件事，软件更纯粹"></a>一生只做一件事，软件更纯粹</h2><p>  我们所运行的系统和普通的家用系统有着本质的区别。无论是windows server、Linux或者更强大的Unix，这些系统本身具有高精确度、简单化、稳定可靠等特点。</p><p>  而这些服务器系统的精简程度简直令人发指。由于服务器不需要外接显示器，所以一些图形化的界面服务程序通通被砍掉，甚至连声卡都不要开启。</p><p>  相比普通的家用操作系统，这些图形化的程序往往占用了大量的空间，计算量和复杂程度较高，导致电脑服务器运行缓慢。而大量多余运行项目排除，使得服务器级别操作系统的目的性更明确，甚至有的服务器穷其一生都是在运行一款Apache，压力比家用电脑小太多。</p><h3 id="Unix系统没有图形化界面，这是搭配的CDE桌面"><a href="#Unix系统没有图形化界面，这是搭配的CDE桌面" class="headerlink" title="Unix系统没有图形化界面，这是搭配的CDE桌面"></a>Unix系统没有图形化界面，这是搭配的CDE桌面</h3><p>  而对于高端的服务器来讲，操作系统的容错性也是完爆家用级别服务器。在家用服务器运行时，一个error弹框就能让整台电脑重启。而服务器如果出现错误，后台自动生成详细的错误分析日志，寻求最佳解决方案保障程序继续运行下去。</p><p><img src="https://outwcl4zh.bkt.clouddn.com/2.jpg" alt="f2"><br>   让人目眩的大规模集群架构</p><p>   做单一的工作虽然简单，但是服务器的处理量是巨大的，这时，大型集群架构就可以发挥他的作用了。一旦服务器负载量增大，大规模集群会让负载均衡化，保障单个服务器不会过载崩溃，整个系统稳定运行。</p><h2 id="其实我也宕机，只是不让你看见"><a href="#其实我也宕机，只是不让你看见" class="headerlink" title="其实我也宕机，只是不让你看见"></a>其实我也宕机，只是不让你看见</h2><p>  当然，我们服务器家族个头有高有矮，情况不一。一些比较低端的服务器只是针对小范围的受众，一旦超出了承载范畴，系统崩溃宕机的事情时有发生。而高端产品也不能完全例外，但是宕机几率和风险要小太多。</p><p><img src="https://outwcl4zh.bkt.clouddn.com/3.jpg" alt="f3"><br>    不同类型的服务器</p><p>  让服务器宕机的原因大致可以分为三种。一，天灾。服务器所处环境不良，维护不够及时，甚至供电不良等；二，人祸。各种应用的设置不当，人为操作失误和破坏以及最常见的大量访问超出了服务上限，导致服务器崩溃。 三，服务器本身原因。服务器质量的差距归根结底是投入的差距。也就是说，服务器的质量越好，成本越高，相应的价格也就越贵。比如，普通的商业级别服务器价格在3000到10万间，而Unix服务器的价格则在30万到3000万。</p><p><img src="https://outwcl4zh.bkt.clouddn.com/4.jpg" alt="f4"><br>        戴尔Unix服务器</p><p>  价格的提升带来的是服务器稳定性的提升。高端的Unix服务器已经达到了可用性99.99%的指标。即具备故障自动恢复能力，年停机时间不超过53分钟。但其超高成本和维护费用也使得很多企业望而却步。目前，也仅有银行、证券保险和电信等行业才会采用。</p><p>  那么如此高端的服务器就可以永不宕机了么？事实恐怕并非如此，此类服务器中比较著名的当属IBM的Z系列服务器。这一款号称“永不宕机”的服务器在2013年也走下了神坛。中国银行所使用IBM的Z系列服务器出现了长达4小时的宕机，造成了巨大的损失。</p><p><img src="https://outwcl4zh.bkt.clouddn.com/5.jpg" alt="f5"><br>    银行所用的IBM Z系列服务器</p><p>  那么大型机也宕机，云服务器宕机么？也会有的。不久前谷歌云刚刚全面中断18分钟，而亚马逊云也曾在2013年出现了40分钟的宕机。而且相比普通的服务器宕机问题，云服务器会显得更为严重。由于公有云用户并不具有控制权，所以能做到就只剩下等待和祈祷了。</p><p>  世界上真的完全没有不宕机的服务器吗？也是有的，美国2004年发射的机遇号火星探测器，从登陆火星到现在已经十余年，从未发生任何故障。该探测器便是采用双机冗余接口的方式搭载了两台IBM P series服务器。</p><p><img src="https://outwcl4zh.bkt.clouddn.com/6.jpg" alt="f6"><br>   机遇号火星探测器</p><p>  如果说宕机是偶尔的风雨，那么不宕机才是服务器支撑起整个互联网行业的脊梁。文章最后，用一张表来为大家总结一下为什么服务器能够不宕机。</p><p><img src="https://outwcl4zh.bkt.clouddn.com/7.jpg" alt="f7"></p><p>  永不宕机在生活中或许只是一个神话，并非每台服务器都能陪你到老。在经历了太多的风霜后，宕机在所难免。我们不是不会宕机，只是在努力不想让你们看见，谁让我们的名字叫做“服务”呢。</p><p>文章转载自<a href="https://blog.sina.com.cn/s/blog_162fcae490102wf94.html">大篆科技</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 那年那器那些事：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;hello，大家好，我叫服务器，承载了全世界互联网行业的光荣与梦想。最近，听说居然有人敢质疑我的权威，说我会不会宕机？明确告诉你，你可以骂我卡，但就是不让你看见我宕机！&lt;br&gt;
    
    </summary>
    
      <category term="资源分享" scheme="https://dexinser.github.io/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="认知提升" scheme="https://dexinser.github.io/tags/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>Webpack学习笔记</title>
    <link href="https://dexinser.github.io/2017/12/Webpack.html"/>
    <id>https://dexinser.github.io/2017/12/Webpack.html</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2022-11-14T16:39:46.712Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Webpack学习笔记：</strong> <Excerpt in index | 首页摘要></p><p>Webpack的中文叫法–我更愿意叫它“前端自动化构建工具”，是用来进行模块化加载并且打包的，它能把各种资源，例如图片、js文件、css预处理语言等等，统统进行处理，打包成符合生产环境部署的前端资源。<br><a id="more"></a></p><The rest of contents | 余下全文><h1 id="什么是Webpack？"><a href="#什么是Webpack？" class="headerlink" title="什么是Webpack？"></a>什么是Webpack？</h1><p>Webpack的中文叫法–我更愿意叫它“前端自动化构建工具”，是用来进行模块化加载并且打包的，它能把各种资源，例如图片、js文件、css预处理语言等等，统统进行处理，打包成符合生产环境部署的前端资源。</p><p>模块化的问题解决之后，webpack 就能把各种资源模块打包合并成一个文件输出给浏览器。在打包的过程中还能对这些资源进行处理，比如压缩减少体积，把 sass 编译成 css, coffee 编译成 js。所以它在某些程度上，跟 grunt/gulp 的功能有些相同。<br><img src="https://outwcl4zh.bkt.clouddn.com/webpack.jpg" alt="Webpack工作模式"></p><h1 id="与grunt-gulp的区别"><a href="#与grunt-gulp的区别" class="headerlink" title="与grunt/gulp的区别"></a>与grunt/gulp的区别</h1><p>grunt/gulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行顺序，来让 grunt/gulp 执行这些 task，从而构建项目的整个前端开发流程。<br><img src="https://outwcl4zh.bkt.clouddn.com/gulp+grunt.png" alt="grunt/gulp"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Webpack学习笔记：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;Webpack的中文叫法–我更愿意叫它“前端自动化构建工具”，是用来进行模块化加载并且打包的，它能把各种资源，例如图片、js文件、css预处理语言等等，统统进行处理，打包成符合生产环境部署的前端资源。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://dexinser.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>编程相关-杂（Relative）</title>
    <link href="https://dexinser.github.io/2017/12/relative.html"/>
    <id>https://dexinser.github.io/2017/12/relative.html</id>
    <published>2017-12-18T16:00:00.000Z</published>
    <updated>2022-11-14T16:39:33.108Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 编程相关-杂（Relative）：</strong> <Excerpt in index | 首页摘要></p><p>windows中sublime一些快捷键的使用。 &amp; 微信小程序的一些简单简介。<br><a id="more"></a></p><The rest of contents | 余下全文><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">li</span>&gt; vscode&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;<span class="built_in">li</span>&gt; <span class="built_in">atom</span>&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;<span class="built_in">li</span>&gt; webstrom&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;<span class="built_in">li</span>&gt;sublime的插件问题&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">&lt;<span class="built_in">li</span>&gt;emmet&lt;/<span class="built_in">li</span>&gt;</span><br><span class="line">emmet插件的简单使用规则：div.<span class="built_in">demo</span>#only*<span class="number">3</span>&gt;p[<span class="built_in">style</span>=<span class="string">"background-color:orange;width:100px;height:100px;"</span>]</span><br><span class="line">div&gt;(p^span.<span class="built_in">demo</span>#only&#123;内容&#125;)</span><br><span class="line">ul&gt;<span class="built_in">li</span>&#123;a$&#125;*<span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="Sublime-Text-3-快捷键精华版"><a href="#Sublime-Text-3-快捷键精华版" class="headerlink" title="Sublime Text 3 快捷键精华版:"></a>Sublime Text 3 快捷键精华版:</h1><p>Ctrl+Shift+P：打开命令面板<br>Ctrl+P：搜索项目中的文件<br>Ctrl+G：跳转到第几行<br>Ctrl+W：关闭当前打开文件<br>Ctrl+Shift+W：关闭所有打开文件<br>Ctrl+Shift+V：粘贴并格式化<br>Ctrl+D：选择单词，重复可增加选择下一个相同的单词<br>Ctrl+L：选择行，重复可依次增加选择下一行<br>Ctrl+Shift+L：选择多行<br>Ctrl+Shift+Enter：在当前行前插入新行<br>Ctrl+X：删除当前行<br>Ctrl+M：跳转到对应括号<br>Ctrl+U：软撤销，撤销光标位置<br>Ctrl+J：选择标签内容<br>Ctrl+F：查找内容<br>Ctrl+Shift+F：查找并替换<br>Ctrl+H：替换<br>Ctrl+R：前往 method<br>Ctrl+N：新建窗口<br>Ctrl+K+B：开关侧栏<br>Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身<br>Ctrl+F2：设置/删除标记<br>Ctrl+/：注释当前行<br>Ctrl+Shift+/：当前位置插入注释<br>Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的<br>Ctrl+Shift+A：选择当前标签前后，修改标签用的<br>F11：全屏<br>Shift+F11：全屏免打扰模式，只编辑当前文件<br>Alt+F3：选择所有相同的词<br>Alt+.：闭合标签<br>Alt+Shift+数字：分屏显示<br>Alt+数字：切换打开第N个文件<br>Shift+右键拖动：光标多不，用来更改或插入列内容<br>鼠标的前进后退键可切换Tab文件<br>按Ctrl，依次点击或选取，可需要编辑的多个位置<br>按Ctrl+Shift+上下键，可替换行<br>选择类<br>Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。<br>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。<br>Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。<br>Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。<br>Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。<br>Ctrl+M 光标移动至括号内结束或开始的位置。<br>Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。<br>Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。<br>Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。<br>Ctrl+Shift+] 选中代码，按下快捷键，展开代码。<br>Ctrl+K+0 展开所有折叠代码。<br>Ctrl+← 向左单位性地移动光标，快速移动光标。<br>Ctrl+→ 向右单位性地移动光标，快速移动光标。<br>shift+↑ 向上选中多行。<br>shift+↓ 向下选中多行。<br>Shift+← 向左选中文本。<br>Shift+→ 向右选中文本。<br>Ctrl+Shift+← 向左单位性地选中文本。<br>Ctrl+Shift+→ 向右单位性地选中文本。<br>Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。<br>Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。<br>Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。<br>Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。<br>编辑类<br>Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。<br>Ctrl+Shift+D 复制光标所在整行，插入到下一行。<br>Tab 向右缩进。<br>Shift+Tab 向左缩进。<br>Ctrl+K+K 从光标处开始删除代码至行尾。<br>Ctrl+Shift+K 删除整行。<br>Ctrl+/ 注释单行。<br>Ctrl+Shift+/ 注释多行。<br>Ctrl+K+U 转换大写。<br>Ctrl+K+L 转换小写。<br>Ctrl+Z 撤销。<br>Ctrl+Y 恢复撤销。<br>Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。<br>Ctrl+F2 设置书签<br>Ctrl+T 左右字母互换。<br>F6 单词检测拼写<br>搜索类<br>Ctrl+F 打开底部搜索框，查找关键字。<br>Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。<br>Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。<br>Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。<br>Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。<br>Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。<br>Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。<br>Esc 退出光标多行选择，退出搜索框，命令框等。<br>显示类<br>Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。<br>Ctrl+PageDown 向左切换当前窗口的标签页。<br>Ctrl+PageUp 向右切换当前窗口的标签页。<br>Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）<br>Alt+Shift+2 左右分屏-2列<br>Alt+Shift+3 左右分屏-3列<br>Alt+Shift+4 左右分屏-4列<br>Alt+Shift+5 等分4屏<br>Alt+Shift+8 垂直分屏-2屏<br>Alt+Shift+9 垂直分屏-3屏<br>Ctrl+K+B 开启/关闭侧边栏。<br>F11 全屏模式<br>Shift+F11 免打扰模式</p><h1 id="微信小程序的一些简单简介："><a href="#微信小程序的一些简单简介：" class="headerlink" title="微信小程序的一些简单简介："></a>微信小程序的一些简单简介：</h1><p>微信小程序中没有关联或者引入标签，只能靠相同的命名来产生关联，比如：index.wxml–index.wxss–index.js–index.json;只能命名相同的名字，然后微信页面就会自动找相同名字来进行关联了。自动进行绑定关联，根据命名把一些东西捆绑在一起。<br>rpx：就是最开始是为了不让在苹果手机上失真而人为设置的一种与真实的px（像素）所在不同手机上的换算关系。所以rpx也就具有了根据不同屏幕进行自适应的功能了。<br>wxml上并没有通配符选择器，但是有json配置文件。没有body标签，但是有pages标签就相当于html中的body标签了。<br>wxml中有很多强大的内置标签，也就是人为封装的组件，恩，很强大的。例如：轮播图组件<swiper>标签，下面有<swiper-item>，<swiper>上有autoplay属性，并伴随着interval=”时间”，是否采用衔接滑动circular=”true”;<br>图标<icon>组件：上面有不同的类型：type=’success/info/..’ color=”color”;<br>地图<map>组件：map组件上还有很多其他的标签和属性方法。总之很强大了！</p><p>wxml没有dom节点，不能像JavaScript一样操作dom元素。但是wxml给了我们一个数据绑定的.js文件。里面有page({});函数调用的形式。通过调用page()这个函数，来注册了一个页面，通过改变page()这个函数来影响UI层面的东西。page()函数里面有一些函数来监听页面的渲染。<br>生命周期函数：<code>onLoad:function(options){}</code>–监听页面加载。<br>生命周期函数：<code>onReady:function(){}</code>–监听页面初次渲染完成。<br>生命周期函数：<code>onShow:function(){}</code>–监听页面显示<br>生命周期函数：<code>onHide:function(){}</code>–监听页面隐藏<br>生命周期函数：<code>onUnload:function(){}</code>–监听页面卸载<br>生命周期函数执行的顺序为：页面先加载触发<code>onLoad</code>函数；再调用<code>onShow</code>函数；之后再调用onReady函数。</p><p>两个层—一个给用户看的视图层，另一个应用层js操作视图层。<br>首先是视图层的初始化init..和应用层的创建creat..一个实例<br>视图层向应用层要一些初始化是数据。切换页面，那么这个页面生命周期就结束了，调用<code>onUnload</code>函数。this就代表这个页面实例。</p><h2 id="编写微信小程序的简单步骤："><a href="#编写微信小程序的简单步骤：" class="headerlink" title="编写微信小程序的简单步骤："></a>编写微信小程序的简单步骤：</h2><p>首先会在app.json文件下查找我们所配置的东西，创建的页面，页面之间的关联还有页面的导航栏（最顶上的一栏）的设置和底边的tabpar分页的切换设置等等都是在这儿实现的。在app.json中配置好了主页面和分页面之后就可以开始编写代码了。<br>如何在微信地图上添加功能按钮：因为在地图上添加<code>&lt;button&gt;</code>按钮是显示不出来的，因为map组件的层级永远在最上面，只能用map组价提供好的controls属性，配合监听对control的点击的回调函数。然后在.js文件中有wx.getSystemInfo这个方法监听设备信息来获取需要设置的相应数据。<br>bindcontroltap，在onShow函数内定义一个app-map执行器上下文（类似canvas的执行期上下文），这个执行器上下文中有一个方法是moveToLocaltion方法，定义一个movetoCenter方法就是执行moveToLocation方法的，然后在switch case中，case到指定的controlId就调用定义好的movetoCenter方法。</p><p>模拟假数据的一个很好用的网站，easy-mock网站，恩，很有年头了。简单的使用：直接进去没有用户名他直接会让你登录，没有的话就会直接帮你注册成功了。注册成功直接创建项目就行了。非常简单就能使用的。假数据写成JSON形式的，然后窗口打开，复制窗口URL地址，然后就能使用这个假数据了。</p><p><a href="https://easy-mock.com/mock/5983e3d1a1d30433d852e683/ofo/getbike">https://easy-mock.com/mock/5983e3d1a1d30433d852e683/ofo/getbike</a></p><h2 id="a-和-a-的区别："><a href="#a-和-a-的区别：" class="headerlink" title="a++ 和 ++a 的区别："></a>a++ 和 ++a 的区别：</h2><pre><code>他们都是已经执行了代码，也就是都已经加一了。但是++a是显示的加上去了，也就是说显示出来了，但是a++是到下一次执行才显示出来，但是上一次的代码已经执行了。ok？</code></pre><h2 id="命名上的一些英文单词："><a href="#命名上的一些英文单词：" class="headerlink" title="命名上的一些英文单词："></a>命名上的一些英文单词：</h2><p>wrapper：包装；<br>navigation：航行（学），航海（术），海上交通；<br>contain：内容；<br>footer: 页脚；<br>header： 页头；<br>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 编程相关-杂（Relative）：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;windows中sublime一些快捷键的使用。 &amp;amp; 微信小程序的一些简单简介。&lt;br&gt;
    
    </summary>
    
      <category term="开发工具" scheme="https://dexinser.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="others" scheme="https://dexinser.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>Npm相关问题</title>
    <link href="https://dexinser.github.io/2017/12/npm.html"/>
    <id>https://dexinser.github.io/2017/12/npm.html</id>
    <published>2017-12-17T16:00:00.000Z</published>
    <updated>2022-11-14T16:38:38.860Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Npm相关问题：</strong> <Excerpt in index | 首页摘要></p><p>简单的来说npm就是nodejs的包管理工具。<br><a id="more"></a></p><The rest of contents | 余下全文><p>简单的来说npm就是nodejs的包管理工具。</p><p>所以说到它就不得不提一下nodejs这个前端发展中出现的里程碑式的后端JavaScript语言。让我们摆脱了浏览器这一个单一的环境限制，开始向后端迈进。</p><p>正是由于nodejs的火爆发展，也带动着前端JavaScript模块化的步伐。由于后端开发是非常复杂的，所以必须使用模块化的开发模式，而随着前端也越来越复杂的应用开发，所以类似后端开发中的模块化开发不得不应用到前端中来了。</p><h1 id="前端模块化开发带来的好处"><a href="#前端模块化开发带来的好处" class="headerlink" title="前端模块化开发带来的好处"></a>前端模块化开发带来的好处</h1><h2 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h2><p>随着前端开发应用的复杂度越来越高，应用开发的团队成员也越来越多，不可避免的就有了命名上的一些冲突，为了解决命名冲突所带来的问题，我们可以用模块化的思想，把各个功能封装在一个模块中。</p><h2 id="文件依赖"><a href="#文件依赖" class="headerlink" title="文件依赖"></a>文件依赖</h2><p>在JavaScript中，由于语言的单线程性质，如果要加载一个js文件，而这个文件依赖于很多个其他的js文件，那么就要很小心的处理加载的先后顺序问题，先把依赖加载进来，在加载依赖这些js的js文件。说起来很拗口哦~（没办法，就这个表达能力啊~）比如：<br>`<script src="util.js"></script></p><p><script src="dialog.js"></script></p><p><script><br>  org.CoolSite.Dialog.init({ /<em> 传入配置 </em>/ });<br></script><code>dialog.js依赖util.js文件中的一些方法，所以必须先要加载完成util.js文件才能正常使用dialog.js中的方法。上面讲的是最简单的文件依赖问题的一些使用方法。但是像上面那样使用很麻烦，所以借鉴后端node的模块化方法，前端引入了类似YUI3库的加载方法，简单实用还美观，如下：</code>YUI.add(‘my-module’, function (Y) {<br>  // …<br>}, ‘0.0.1’, {<br>    requires: [‘node’, ‘event’]<br>});`</p><p>上面的代码，通过 requires 等方式来指定当前模块的依赖。这很大程度上可以解决依赖问题，但不够优雅。当模块很多，依赖很复杂时，烦琐的配置会带来不少隐患。</p><p>命名冲突和文件依赖，是前端开发过程中的两个经典问题。下来我们看如何通过模块化开发来解决。为了方便描述，我们使用 Sea.js 来作为模块化开发框架。</p><h1 id="使用Sea-js来解决"><a href="#使用Sea-js来解决" class="headerlink" title="使用Sea.js来解决"></a>使用Sea.js来解决</h1><p>先说一下这些模块的发展吧。前面说了前端模块化是借鉴的node后端模块化的思想。而node又是遵循的服务器端模块的规范–&gt;CommonJs。</p><h2 id="CommonJS-（服务器端的模块化规范）"><a href="#CommonJS-（服务器端的模块化规范）" class="headerlink" title="CommonJS （服务器端的模块化规范）"></a>CommonJS （服务器端的模块化规范）</h2><p>根据CommonJs规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。如下：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1&gt; </span>math.js</span><br><span class="line">exports.add = function() &#123;</span><br><span class="line">    var sum = <span class="number">0</span>, i = <span class="number">0</span>, args = arguments, l = args.length;</span><br><span class="line">    while (i &lt; l) &#123;</span><br><span class="line">        sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">2&gt; </span>increment.js</span><br><span class="line">var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">exports.increment = function(val) &#123;</span><br><span class="line">    return add(val, <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">3&gt; </span>main.js，该文件为入口文件</span><br><span class="line">var inc = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">var a = <span class="number">1</span>;</span><br><span class="line">inc(a); // <span class="number">2</span></span><br></pre></td></tr></table></figure><p>CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，网络请求资源的方式，速度相对较慢，就必须采用异步加载的模式。所以就有了 AMD  CMD 的解决方案。<br>模块的要求如下：</p><blockquote><p>标示符require，为一个函数，它仅有一个参数为字符串，该字符串须遵守Module Identifiers的6点规定<br>require方法返回指定的模块API<br>如果存在依赖的其它模块，那么依次加载<br>require不能返回，则抛异常<br>仅能使用标示符exports导出API</p></blockquote><h2 id="AMD（Asynchromous-Module-Definition）异步模块定义"><a href="#AMD（Asynchromous-Module-Definition）异步模块定义" class="headerlink" title="AMD（Asynchromous Module Definition）异步模块定义"></a>AMD（Asynchromous Module Definition）异步模块定义</h2><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>AMD异步加载模块。它的模块支持 对象、 函数、 构造器、 字符串、 JSON 等各种类型的模块。 </p><p>使用AMD规范适用define方法定义模块。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过数组引入依赖 ，回调函数通过形参传入依赖 </span></span><br><span class="line">define([<span class="string">'someModule1'</span>, ‘someModule2’], <span class="function"><span class="keyword">function</span> (<span class="params">someModule1, someModule2</span>) </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="comment">/// something </span></span><br><span class="line">        someModule1.test(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">foo</span>: foo&#125; </span><br><span class="line">&#125;); </span><br><span class="line">AMD规范允许输出模块兼容CommonJS规范，这时define方法如下： </span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> reqModule = <span class="built_in">require</span>(<span class="string">"./someModule"</span>); </span><br><span class="line">    requModule.test(); </span><br><span class="line">     </span><br><span class="line">    exports.asplode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="comment">//something </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>定义模块用module变量，它有一个方法declare<br>declare接受一个函数类型的参数，如称为factory<br>factory有三个参数分别为require、exports、module<br>factory使用返回值和exports导出API<br>factory如果是对象类型，则将该对象作为模块输出</p></blockquote><p>目前，实现AMD的库有 RequireJS  、 curl  、 Dojo  、 bdLoad 、 JSLocalnet  、 Nodules  等。</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD是SeaJS 在推广过程中对模块定义的规范化产出。<br>Sea.js 是国内前端大神玉伯写出来的一个成熟的开源项目，核心目标是给前端开发提供简单、极致的模块化开发体验。这里不多做介绍，有兴趣的可以访问 seajs.org 查看官方文档。</p><p>使用 Sea.js，在书写文件时，需要遵守 CMD （Common Module Definition）模块定义规范。一个文件就是一个模块。如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line">  exports.each = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  exports.log = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">通过 exports 就可以向外提供接口。这样，dialog.js 的代码变成</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'./util.js'</span>);</span><br><span class="line"></span><br><span class="line">  exports.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实现代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>关键部分到了！我们通过 require(‘./util.js’) 就可以拿到 util.js 中通过 exports 暴露的接口。这里的 require 可以认为是 Sea.js 给 JavaScript 语言增加的一个语法关键字，通过 require 可以获取其他模块提供的接口。</p><p>这其实一点也不神奇。作为前端工程师，对 CSS 代码一定也不陌生。</p><p><code>@import url(&quot;base.css&quot;);</code></p><p><code>#id { ... }.class { ... }</code><br>Sea.js 增加的 require 语法关键字，就如 CSS 文件中的 @import 一样，给我们的源码赋予了依赖引入功能。</p><h1 id="CMD和AMD的区别有以下几点："><a href="#CMD和AMD的区别有以下几点：" class="headerlink" title="CMD和AMD的区别有以下几点："></a>CMD和AMD的区别有以下几点：</h1><ol><li><p>对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式也不同）。 </p></li><li><p>AMD推崇依赖前置，CMD推崇依赖就近。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AMD </span></span><br><span class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">    <span class="comment">//依赖一开始就写好 </span></span><br><span class="line">    a.test(); </span><br><span class="line">    b.test(); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">//CMD </span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123; </span><br><span class="line">    <span class="comment">//依赖可以就近书写 </span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>); </span><br><span class="line">    a.test(); </span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//软依赖 </span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123; </span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>); </span><br><span class="line">        b.test(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>虽然 AMD也支持CMD写法，但依赖前置是官方文档的默认模块定义写法。 </p><ol start="3"><li>AMD的API默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require ,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。 </li></ol><hr><hr><p>好了，说完了上面的介绍，该正式讲一下正文了~</p><h1 id="npm-三个版本的区别简介"><a href="#npm-三个版本的区别简介" class="headerlink" title="npm 三个版本的区别简介"></a>npm 三个版本的区别简介</h1><p>如今npm包管理已经有3个版本了，那就来讲一下他们之间的区别吧~</p><h2 id="npm-v2解析包的依赖关系"><a href="#npm-v2解析包的依赖关系" class="headerlink" title="npm v2解析包的依赖关系"></a>npm v2解析包的依赖关系</h2><p>想像一下现在有三个模块module A、module B、module C。A依赖B的V1版本，C依赖于B的V2版本。 npm采取的方式是把依赖的模块包嵌入子目录。</p><h2 id="npm-V3-解析包的依赖关系"><a href="#npm-V3-解析包的依赖关系" class="headerlink" title="npm V3 解析包的依赖关系"></a>npm V3 解析包的依赖关系</h2><p>npm3和npm2的不同之处在于：</p><blockquote><p>npm2使用嵌套的方式来管理依赖包，npm3尝试缓和过长的包依赖路径问题。 把二级依赖的包安装在同一级目录下。</p></blockquote><p>假设我们有一个模块A依赖模块B。我们在安装模块A的时候，在项目的node_modules文件夹下： 可以看到 npm v2与npm v3的差异是npm v3中A和B是再同一层文件夹中的，而npm v2中B是再A文件夹下嵌套的。</p><p>现在我们需要安装一个模块C，模块C依赖模块B但是版本与模块A依赖的不同。</p><p>由于B v1.0已经安装在node_modules目录的根目录下了，不能把B v2.0也安装在根目录下。这个时候npm v3的处理方式和npm v2类似。</p><p>通过 npm ls 查看当前项目所有包的依赖关系。如果只是想看顶级包的依赖关系可以执行npm ls –depth=0。</p><h2 id="npm-v3去重"><a href="#npm-v3去重" class="headerlink" title="npm v3去重"></a>npm v3去重</h2><p>也正因为npm v3版本中的新特性，所以就会出现一些重复的包下载，我们可以用提供给我们的API来进行删除重复的包。<br><strong>npm dedupe</strong></p><p>该命令会删除node_modules顶级目录下没有被使用的模块，并且把被重复依赖的模块移动到顶级目录下。</p><p>接下来看一下最新版的npm的一些命令用法吧~</p><h1 id="npm-最新用法"><a href="#npm-最新用法" class="headerlink" title="npm 最新用法"></a>npm 最新用法</h1><h2 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h2><p>用过npm的对这个命令一定熟悉的不能再熟悉了吧~<br><code>$ npm install &lt;packageName&gt;</code><br>安装之前，npm install会先检查，node_modules目录之中是否已经存在制定模块。如果存在，就不再重新安装，既是运程仓库已经有了一个新版本，也是如此。</p><p>如果你希望，一个模块不管是狗安装过，npm都要强制重新安装，可以使用-f或者–force命令参数。<br><code>$ npm install &lt;packageName&gt; --force</code></p><h2 id="npm-update"><a href="#npm-update" class="headerlink" title="npm update"></a>npm update</h2><p>如果想更新已安装模块，就要用到npm update命令了。<br><code>$ npm update &lt;packageName&gt;</code><br>它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本有更新，就会安装最新版本。</p><h2 id="registry"><a href="#registry" class="headerlink" title="registry"></a>registry</h2><p>npm update命令怎么知道每个模块的最新版本呢？<br>答案是npm模块仓库提供了一个查询服务，叫做registry。以npmjs.org为例，它的查询网址是<a href="https://registry.npmjs.org/。">https://registry.npmjs.org/。</a></p><p>这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。比如，访问 <a href="https://registry.npmjs.org/react，就会看到">https://registry.npmjs.org/react，就会看到</a> react 模块所有版本的信息。</p><p>它跟下面命令的效果是一样的。</p><p>`$ npm view react</p><h1 id="npm-view-的别名"><a href="#npm-view-的别名" class="headerlink" title="npm view 的别名"></a>npm view 的别名</h1><p>$ npm info react<br>$ npm show react<br>$ npm v react`</p><p>registry 网址的模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息。比如， 访问 <a href="https://registry.npmjs.org/react/v0.14.6">https://registry.npmjs.org/react/v0.14.6</a> ，就可以看到 React 的 0.14.6 版。</p><h1 id="npm-的常用命令行代码："><a href="#npm-的常用命令行代码：" class="headerlink" title="npm 的常用命令行代码："></a>npm 的常用命令行代码：</h1><ol><li>npm install moduleNames：安装Node包（moduleNames包名称）<br>（1）npm install moduleNames -g 为全局安装<br>（2）npm install <a href="mailto:moduleNames@5.1.1">moduleNames@5.1.1</a>  安装特定版本插件<br>（3）npm install moduleNames –save 会在package.json的dependencies属性下添加moduleNames  即发布依赖时候任依赖的插件<br>（4）npm install moduleNames –save-dev  会在package.json的devDependencies属性下添加moduleNames依赖 即开发依赖插件<br>总结：npm install 在安装 npm 包时，有两种命令参数可以把它们的信息写入 package.json 文件，一个是npm install –save另一个是 npm install –save-dev，他们表面上的区别是–save 会把依赖包名称添加到 package.json 文件 dependencies 键下，–save-dev 则添加到 package.json 文件 devDependencies 键下。<br>真正跑在用户浏览器中的代码，比如jquery,react这些，是需要安装到dependencies中的。<br>–save是对生产环境所需依赖的声明(开发应用中使用的框架，库),–save-dev是对开发环境所需依赖的声明(构建工具，测试工具).正常使用npm install时，会下载dependencies和devDependencies中的模块，当使用npm install –production或者注明NODE_ENV变量值为production时，只会下载dependencies中的模块。</li><li>npm config set registry <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a>  修改包下载源，此例修改为了淘宝镜像</li><li>npm config get prefix  查看全局安装路径</li><li>npm config set prefix G:/node_modules_global  修改全局安装路径</li><li>npm init  初始化目录</li><li>npm install -g gulp  全局安装（如gulp）</li><li>npm uninstall -g gulp    全局包卸载（如gulp）</li><li>npm uninstall gulp –save-dev  项目本地卸载（如gulp）</li><li>npm ls –global    会查看到安装包所包含的所有依赖文件   npm ls –global -depth 0  只查看顶级安装包</li><li>npm ls  查看本地安装包</li><li>npm cache clean  删除安装包缓存</li><li>npm  update xxx  更新安装包</li><li>npm search xxx  查找验证某个包是否已经存在</li><li>npm root 查看当前包安装路径  npm root -g  查看全局包安装路径</li><li>npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新</li><li>npm view xxx engines：查看包所依赖的Node的版本</li><li>npm view xxx repository.url：查看包的源文件地址</li><li>npm view xxxpendencies：查看包的依赖关系</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Npm相关问题：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;简单的来说npm就是nodejs的包管理工具。&lt;br&gt;
    
    </summary>
    
      <category term="开发工具" scheme="https://dexinser.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="node" scheme="https://dexinser.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Math.floor()等方法的用法</title>
    <link href="https://dexinser.github.io/2017/12/Math.floor()%E6%96%B9%E6%B3%95.html"/>
    <id>https://dexinser.github.io/2017/12/Math.floor()方法.html</id>
    <published>2017-12-16T16:00:00.000Z</published>
    <updated>2022-11-14T16:38:28.967Z</updated>
    
    <content type="html"><![CDATA[<p>Math.floor()方法的深层解析<br><a id="more"></a></p><The rest of contents | 余下全文><h2 id="Math-floor-方法的深层解析"><a href="#Math-floor-方法的深层解析" class="headerlink" title="Math.floor()方法的深层解析"></a>Math.floor()方法的深层解析</h2><p>  大家都知道这是一个JavaScript的基础的方法—向下取整，但是你们有没有遇到过这个方法不听话呢？哈哈，接下来就让我们来领教一下这个方法什么时候才会出现不听话吧！<br>  <code>!function test(){            var is = 100;            window.setInterval(function(){                is = is/7;                Math.floor(is);                console.log(is)            },10)        }()</code><br>        这个方法之后的结果为14.124235…<br>这段代码中就用到了Math.floor()这个方法，但是这个方法就在这个时候不听话了，is这个变量居然一直取到了小数点后好多好多位。这是为什么呢？其实并不是这个方法不好用了，只是我们把这个方法用错了而已，因为is这个变量是一个Number类型的数字，是一个原始值（栈类型）不可改变。所以上面的代码我们访问的其实还是原来的is的值，并没有访问Math.floor()之后的is值。<br>我们可以这样访问到Math.floor()之后的is值。代码如下：<br><code>!function test(){            var is = 100;            window.setInterval(function(){                is = is/7;                console.log(Math.floor(is);)            },10)        }()</code><br>这样之后的结果就是14了。<br>通过这篇文章，只是想告诉你，JavaScript语言的一些值的类型，有引用值和原始值，引用值也就是堆数据类型的值，原始值在JavaScript语言中有undefined、Number、Boolean、String等，并且不同的值类型之间的不同的区别是什么，尤其重要的是千万不要试图去改变原始值，因为你真的拗不过他们的！哈哈，好了，就这样了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Math.floor()方法的深层解析&lt;br&gt;
    
    </summary>
    
      <category term="基础方法分享" scheme="https://dexinser.github.io/categories/%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="JavaScript" scheme="https://dexinser.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js模式读书笔记</title>
    <link href="https://dexinser.github.io/2017/12/js%E6%A8%A1%E5%BC%8F-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>https://dexinser.github.io/2017/12/js模式-读书笔记.html</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2022-11-14T16:38:16.193Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Js模式读书笔记：</strong> <Excerpt in index | 首页摘要></p><p>模式：广义上是重现事件或用来生产者对象是主题···它是一个可以用来生产其他事物的模板或者模型。在软件开发过程中，模式是指一个通用问题的解决方案。<br><a id="more"></a></p><The rest of contents | 余下全文><h2 id="js模式笔记"><a href="#js模式笔记" class="headerlink" title="js模式笔记"></a>js模式笔记</h2><p>  模式：广义上是重现事件或用来生产者对象是主题···它是一个可以用来生产其他事物的模板或者模型。在软件开发过程中，模式是指一个通用问题的解决方案。一个模式不仅仅是一个可以用来复制粘贴的代码解决方案，更多的是提供了一个更好的实践经验、有用的抽象化表示和解决一类问题的模板。<br>在JS中，一旦定义好了变量，同时也就已经正在处理对象向了。该变量会成为内置对象的一个属性，成为激活对象。第二，该变量实际上也是伪类，因为他拥有其自身的属性（attributes），该属性决定了该变量是否可以被修改、被删除和在一个for-in循环中进行枚举。<br>一个对象仅仅是一个容器，该容器包含了命名的属性、健-值对（大多数）的列表。这里面的属性可以是函数（函数对象），这种情形下我们称其为方法。对象有两种类型：原生的（Native）：内置对象（例数组、日期对象等）和用户自定义对象（例var a={}）   主机的（Host）：Windows对象和所有的DOM对象。</p><p>尽量少用全局变量！尽量使用var声明变量。<br>使用var创建的全局变量不能删除。不适用var创建的隐含全局变量可以删除。这表明隐含全局变量严格来讲不是真正的变量，而是全局的属性。属性可以通过delete操作符删除，但变量不可以。<br>尽量使用一个var声明全部变量，这样可以减少逻辑错误和提高代码的可读性。<br>凌散变量的提升。不管在函数的任何地方声明变量，效果都等同于在函数顶部进行声明。</p><p>for-in循环应该用来遍历非数组对象。一般用for循环遍历数组。使用for-in遍历非数组对象时都要结合.hasOwnProperty（）。</p><p>不要增加内置的原型。容易引发混乱，引起错误等。</p><p><code>var inspect_me = 0,      result = &#39;&#39;;  switch（inspect_me）{  case 0：     result = “zero”；     break；  case 1：     result = “one”；     break；  default：     result = “unknown”；  }</code></p><p>避免使用隐式类型转换。false==0或”” == 0这类比较语句后会返回true。</p><p>避免使用eval（），他可以将任意字符串当做一个JavaScripe代码来执行。</p><p>parseInt()的数值约定。传的第二个参数是一个进制参数，尽量不要省略该参数。还有截断字符只返回数字类型的功能。</p><p>关于分号的使用，尽管解析器会在代码的每行的结尾隐式的加上分号，但是一般情况下我们还是不应该省略，这不仅是严格记录和代码编写方式，也会有助于避免之前范例中含糊不清的情况。</p><p>使用空格，例如：<code>for (var i = 0; i &lt; 10; i += 1){...}   var a = [1, 2, 3];   var o = {a: 1, b: 2};</code><br>命名约定：构造函数的首字母大写。其他命名模式，有时候开发者采用将变量名全部大写的约定来表明该变量在程序生命周期中不可改变，例如：var PI = 3.14,表示是精确的常量，请不要修改。<br>还有的程序员使用一种约定来模仿功能性的做法是私有成员函数约定。使用一个下划线前缀来标识私有方法或者私有属性是更为简单的一种方法。例如：var person = {<br>   _getFirst: function () { }表示私有函数，使用下划线前缀的表示方法可以提醒使用person对象的用户，告诉他们这些方法在其他地方不能确定一定能够正常工作，不能直接调用。<br>}</p><p>下面是一些使用下划线约定的变量：<br>使用下划线结尾来表明是私有变量，例如name_和getElements_()。<br>使用一个下划线前缀来标识受保护属性，使用两个下划线前缀来标识私有属性。<br>在Firefox中有一些属性，这些属性技术上不是JavaScript语言的一部分，它们采用两个下划线前缀和两个下划线后缀来命名。例如<strong>proto</strong>and__parent__。</p><p>编写注释。因为人的记忆力不是永久的，过了一段时间你自己写的代码可能你都不能认识了。最重要的习惯，也是最难遵循的习惯就是不断更新注释，因为过期的注释可能会误导阅读者，这比没有注释还可怕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Js模式读书笔记：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;模式：广义上是重现事件或用来生产者对象是主题···它是一个可以用来生产其他事物的模板或者模型。在软件开发过程中，模式是指一个通用问题的解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="book" scheme="https://dexinser.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>Js笔记</title>
    <link href="https://dexinser.github.io/2017/12/js%E7%AC%94%E8%AE%B0.html"/>
    <id>https://dexinser.github.io/2017/12/js笔记.html</id>
    <published>2017-12-14T16:00:00.000Z</published>
    <updated>2022-11-14T16:37:48.662Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Js笔记：</strong> <Excerpt in index | 首页摘要></p><p>js笔记 - typeof | parseInt | &amp;&amp; 与运算符 | || 或运算符 | parseFloat | 作用域 | instance of | 练习题~<br><a id="more"></a></p><The rest of contents | 余下全文><h2 id="js笔记"><a href="#js笔记" class="headerlink" title="js笔记"></a>js笔记</h2><p>typeof 识别不了Object与Array与null（历史遗留性问题）<br>返回六种数据类型number、string、booblean、undefined、object、function。</p><p>隐示类型转化：Number()类型的数据转化，typeof之后会把true返回数值1，false返回值为0。“123”转化成123。undefined转化成数值NaN。null转化成数值0。“”空字符串转化成0。</p><p>parseInt(“123abc”)会把字符串类型的转换成整数类型Number类型的123，并且在非数字位置截断。但是只会把其它的undefined和null和true、false等转化NaN。    parseInt（“123”，radix）radix是基底，取值范围是2–36（0也行，有的浏览器中会把0当做10进制的数）。填上第二位的话会把前面的123按照所填的基底转化成10进制的数。</p><p>只有六个值转化成booblean值为false，分别是undefined、null、0、””、false、NaN。其它所有转化成boollean值都为true。</p><p>&amp;&amp; 与运算符，找到一个false就返回。如0 &amp;&amp; 1；直接返回值0。1 &amp;&amp; 2 &amp;&amp; 3；返回值为3。全真才为真，有一个假就是假；</p><p>|| 或运算符， 找到一个真就返回。如0 || 1 || 2，返回值为1。1 || 0，返回值为1。全假才为假，有一个真就是真。</p><p>parseFloat(“10.234”)可以把字符串类型的转化成小数类型的数值类型，即浮点型。</p><p>String（undefined）–&gt; “undefined”  会把一切东西转化成字符串类型的。</p><p>对象.toString方法，与String相似，只不过他是一种方法。只有undefined和null没有这个方法，不能调用这个方法。toString(radix),这个radix跟parseInt中的radix正好相反。按照10进制转换成所填基底的数。</p><p>数学符号有隐式类型转换，只有+号特别，会与字符形式的连接起来。</p><p>null == undefined返回结果为true。 0 == “”返回结果为true。</p><p>对象.toFixed(3)方法表示的是保留小数点后3位有效数字，科学计数法。</p><p>作用域：当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，   ！！它所产生的！！！  执行期上下文被销毁。<br>   查找变量：从作用域的顶端依次向下查找。</p><p> <code>function a() {    function b() {        console.log(b);        }      var a = 123;    b();  }  var glob = 100;  a();</code><br>函数a的执行也就是函数b定义的开始，函数b在刚定义的时候就保存了函数a的劳动成果。变量只有在执行的时候才会被赋值。</p><p>   闭包<br><code>function a() {    var arr = [];    for(var i = 0; i &lt; 10; i++) {        arr[i] = function () {            console.log(i + &quot;,&quot;);        }    }    return arr;   }   var demo = a();   for(var j = 0; j &lt; 10; j++) {    demo[j]();   }</code><br>上题中的i与函数形成闭包，所以结果会打印出10个10。题中的i在函数还没执行时不会被赋值，要等到函数最后执行的时候才会进行赋值，函数执行时for循环就已经转了10圈了，所以i直接进行赋值就成了10个10。运用立即执行函数可以每一圈都让i赋值。<br>我们想要依次打印出i从0到9，但是这样的话就打印不出来我们想要的结果。所以只能靠闭包才能实现我们想要的结果。如下：</p><p><code>function a() {  var arr = [];  for(var i = 0; i &lt; 10; i++) {    (function (j) {      arr[j] = function () {        console.log(j);      }    }(i))  }  return arr;   }   var demo = a();   for(var j = 0; j &lt; 10; j++) {  demo[j]();   }</code><br>值得注意的是这个函数中的demo是一个数组，执行时不能像demo()这样，需要如上题那样进行。</p><pre><code>闭包会导致原有作用域链不释放，造成内存泄露。闭包会导致多个执行函数共用一个公有变量，如果不是特殊需要，应尽量防止这种情况放生。</code></pre><p>一个函数连续执行的话会在他之前形成的作用域链上再作用。</p><p>闭包的作用：1、公有变量   累加器（多次调用的是一个变量）<br>       2、可以做缓存，存储变量   （操作的是同一个变量，把变量放在那儿，多个函数都使用它）   3、模块化开发，防止污染全局变量   4、私有化变量<br><code>function Deng () {  var prepareWife = &quot;xiaozhang&quot;;  var obj = {    name : &quot;dengxuming&quot;,    age : 40,    sex : &quot;male&quot;,    wife : &quot;xiaoliu&quot;,    divorce : function () {      delete this.wife;    },     getMarried : function () {      this.wife = prepareWife;      },    changePrepare : function (someone) {      prepareWife = someone;    },    sayMyWife : function () {      return this.wife;    }    }    return obj;    }    var deng = Deng();</code></p><p>  立即执行函数：此类函数没有声明，在一次执行过后即释放。适合做初始化工作。<br>（function () {}）()  就是长这个样子。执行完就被销毁，所以一般不写名。    只有表达式才能被执行。123就是一个表达式。函数声明不能被执行。成等式就是表达式。表达式被执行完了它就会被销毁，就找不到了。例如下面这个例子：<br>`  var a = function () {<br>                              console.log(‘a’);<br>                            }()  </p><pre><code>+ function () {  console.log(&apos;a&apos;);}()  `                          (在函数声明之前加上+ - ！之后也能执行)</code></pre><p>这个函数执行完之后就不能找到a函数了。</p><p>  认识对象<br><code>var mrYao = {  firstName : &quot;xiaoyao&quot;,  lastName : &quot;yao&quot;,  age : 99,  handsome : false,   son : {    name : wang,    age : 180  }  wife : {    name : zhou,    age : 90      }  smoke : function () {    console.log(&#39;I am smoking, cool&#39;);    }  drink: function () {    console.log(&#39;I am drinking&#39;);  }  }</code><br>  对象可以增删改查！<br>  delete后面加空格，就是使用这个方法，可以把对象的属性和方法删除。</p><p>对象的创建方法有  1、字面量   2、构造函数  （系统自带 new Object（）；Array（）；Boolean（）；String（）；自定义）  3、</p><p>系统的构造方法 var obj = new Object();就相当于var obj = {};叫：对象字面量/对象直接量</p><p>系统的构造方法不够好，可以自定义构造函数。</p><p>`function Person() {</p><p>}<br>var person = new Person;`<br>自定义构造函数大头风原则。</p><p>构造函数内部原理。使用new操作符会在内部隐式的进行三部曲。<br>1、在函数最前面隐式的加上this = {}  2、执行 this.xxx = xxx;<br>  3、隐式的(return)返回this<br>通过new出来的对象，如果你手动的加上return返回一个引用值的时候，那么系统的new隐式进行的三部曲中的第三步就不能返回this了，而会返回手动加上的return的东西。但是只要你手动加上的return返回的结果不是引用值，而是原始值的话不影响构造函数的内部原理的。</p><p>包装类。给原始值加属性、方法，访问原始值的属性、方法等等，都是包装类干的。系统内部自动给你加的。例如：<br><code>var num = 123;  num.abc = &#39;a&#39;;  console.log(num.abc);</code>结果为：undefined<br>因为num是一个原始值，数字类型的，系统会在内部隐式的给你转换成系统内部的Number对象，给你new出来。不过系统隐式的给你new出来之后没有保存他，只是没有让他报错，也并没有保存起来，所以访问不到他。再例如：<br><code>var str = &#39;abcd&#39;;  str.lenth = 2;  console.log(str.length);</code>结果为：4<br>因为str是一个字符串类型的原始值，他上面并没有.length方法，但是系统会把它隐式的new出来，new String（str）.length也就是4了。</p><p>原型  ：原型是对象function的一种属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。<br>利用原型特点和概念，可以提取共有属性。<br>对象如何查看对象的构造函数，constructor。<br><code>Person.prototype.name = &quot;abc&quot;;function Person() {}var person = new Person();Person.prototype.name = &quot;bcd&quot;;console.log(person.name);</code><br>结果为：bcd   (因为这是直接赋值的。注意跟下一题的区别。这个是原始值也就是在栈里面存着)</p><p><code>Person.prototype = { name : &quot;abc&quot;}function Person() {}var person = new Person();Person.prototype = {   name : &quot;bcd&quot;}console.log(person.name);</code><br>结果为：abc     (因为这个是引用值也就是在堆内存里面存着。而且这个person是Person  new出来的，所以有隐式的三步，在this里面会有<strong>proto</strong>=Person.prototype。而new又在第二次引用赋值之前，所以并不会改变name的值，因为<strong>proto</strong>已经提取到第一个name的值了)</p><p> `  Son.prototype = {<br>      eat : function () {<br>        this.height ++;<br>        card : [100, 200]<br>      }</p><pre><code> }; function Son() {this.height = 100; } var son = new Son; son.eat();   101 son.eat();   102 son.card.pop();`   200   拿出来200，原型里面就没有200了</code></pre><p>  son 可以调用父亲Son的值，但是并不能改变父亲Son中的值。也就是说son.<strong>proto</strong>.height的值永远都是100。</p><p>绝大数对象的最终都会继承自Object.prototype<br><code>var demo = {  name : &#39;abc&#39;,  age :234  }var obj = Object.create(demo);</code><br>创建一个obj对象是以demo为原型的对象。括号里必须填东西，想要创建一个没有原型的对象里面要填null。</p><p>一个对象上的<strong>proto</strong>是追到他的父级的原型链上的，所有的对象的<strong>proto</strong>都会追到系统的Object上的，所以Object上就没有<strong>proto</strong>了。如果改变了一个对象上的<strong>proto</strong>就相当于改变了他的原型链，也就是改了他的父级的.prototype原型链了。原型链是一个对象，对象是引用值，修改的话就是换地址的，原先的空间并不会换的。比如：<br><code>var obj = {name:&quot;a&quot;}; var obj1 = obj; obj = {name:&quot;b&quot;};console.log(obj1.name)</code>;结果为：a    ()</p><p><code>var obj = {}; document.write(obj);</code> 打印结果为：[object Object]   因为打印一个文档流的话会隐式的把obj上的toString方法的结果给你打印出来。例如：<code>var obj = Object.create(null);obj.toString = function () {return &#39;邓哥身体好&#39;；}  document.write(obj);</code>  结果为：邓哥身体好<br>但是数字类型的，布尔类型的，数组类型的他们toString出来的就不是[object Object]形式的，因为他们的原型上就有重写的toString方法。    </p><p>toString方法是在原型链上的，所以一般都有，可以完全的分别出来对象，数组等等。但是undefined和null没有toString，因为他俩没有原型链。数字有toString，但是不能直接123.toString，因为数字后面跟着小数点会把这个小数点当做是浮点类型的小数点的。</p><p>浏览器有一个存在的bug。就比如0.14<em>100结果就为140.0000000002；精度不准的问题。<br>Math.radom().这是生成0-1之间的随机数，比如：for(var i = 0; i &lt; 10; i ++) {var num = Math.random().toFixed(2) </em> 100;<br>console.log(num);} 这个就会出现精度不准的问题，就说因为计算机的精度不准，在处理小数不准是因为计算机是基于二进制编码的原因，无法修改的bug。toFixed()就有这个问题。上一题解决的办法就是不用toFixed()在最后取整用floor。比如：for(var i = 0; i &lt; 10; i ++) {var num = Math.floor(Math.random() * 100);  console.log(num);}这次取整就不会出现不精准的问题了。</p><p>函数.call方法的使用。test()其实就是test.call();这个方法可以改变this的指向。括号里面的第一位参数就是this指向的对象，第二位开始可以放正常的参数了。缺点就是还调用了另一个函数，如下：<br><code>function Wheel(wheelSize, style) {  this.style = style;  this.wheelSize = wheelSize;}function Sit(c, sitColor) {  this.c = c;  this.sitColor = sitColor;}function Model(height, width, leng) {  this.height = height;  this.width = width;  this.leng = leng;}function Car(wheelSize, style, c, sitColor, height, width, leng) {  Wheel.call(this, wheelSite, style);  Sit.call(this, c, sitColor);  Model.call(this, height, width, len);}var car = new Car(100, &#39;花里胡哨的&#39;, &#39;真皮座椅舒适&#39;， &#39;red&#39;, 1800, 1900, 4900);</code><br>企业开发的模块化，最后完工的成品是多个拼接起来的。</p><p>call 和apply的区别：call需要把实参按照形参的个数传进去；   apply需要传一个arguments数组。<br>call和apply都是改变this指向，区别就是传参列表不同。</p><p>typeof (new Array).<strong>proto</strong>.constructor()<br>结果为：”object”     解析：先算括号里面的，再算点。优先级顺序。形式上又有typeof的两种形式的用法。</p><p>计算输入变量的字节长度，汉字的Unicode长度大于255，英文字母的Unicode长度小于等于255；<br><code>var str = &quot;kjfhasdkjf生命在于学习&quot;function bytestLength(str) {   var count = str.length;   for(var i = 0; i &lt; str.length; i++) {  if(str.charCodeAt(i) &gt; 255) {     count ++;  }  }  return count;}或者var str = &quot;aldshfuioasdhf&quot;;function bytestLength(str) {   var count = 0;   for(var i = 0, len = str.length; i &lt; len; i ++) {  if(str.charCodeAt(i) &gt; 255) {     count += 2;  }else {     count ++;  }   }   return count;}</code></p><p>继承发展史：<br>1、传统形式—-&gt;原型链    缺点：过多的继承了没用的属性<br>2、借用构造函数   也就是用call或者apply的方法，其实是调用跟自己完全囊括的属性才能使用的，多调用了一次构造函数浪费效率了。    缺点：不能继承借用构造函数的原型； 每次构造函数都要多走一个函数<br>3、共享原则，共有原型。     缺点：不能随便改动自己的原型</p><p>圣杯模式：(构造函数想完全继承自父亲的原型，并且还可以添加自己特有的原型)<br>`Father.prototype.lastName = “Deng”;<br>Father.prototype.sex = “male”;<br>function Father() {</p><p>}<br>function Son() {</p><p>}<br>function inherit(Target, Origin) {<br>   function F() {};<br>   F.prototype = Origin.prototype;<br>   Target.prototype = new F();<br>   Target.prototype.constuctor = Target;<br>   Target.prototype.uber = Origin.prototype;<br>}<br>inherit(Son, Father)<br>var son = new Son();<br>var father = new Father();`</p><p>yahoo的YUI3库现在不用这个了。现在都用jQuery库了。YUI3库是这样写的<br><code>var inherit = (function () {      var F = function () {};      return function (Target, Origin) {      F.prototype = Origin.prototype;      Target.prototype = new F();      Target.prototype.constuctor = Target;      Target.prototype.uber = Origin.prototype;      }    }());</code>    运用闭包的私有化变量属性。必须熟练掌握闭包的属性特点。</p><p>命名空间的问题。防止污染全局变量。一般解决办法就是使用立即执行函数，在立即执行函数里命名变量，变量会成为私有化变量，也就是利用闭包的特点。init初始化、入口。</p><p>对象还有一种访问属性的方法，除了obj.name访问对象obj的name属性，还可以obj[‘name’];浏览器在执行obj.name的时候回隐形的转换成name转换成字符串类型的形式执行，所以用字符串的形式更加快，有效率。而且使用字符串的形式这种方法更加的方便，在以后的使用中，字符串的使用频率更加高的。</p><p>对象、数组的遍历、枚举；<code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; for(var i = 0; i &lt; arr.length; i++) {console.log(arr[i]);}</code></p><p>遍历对象的话就要用到for-in 循环了；<br>  <code>var obj = {       name : &#39;abc&#39;,       age : 123,       sex : &#39;male&#39;,       height : 180,       weight : 75     }     for(var prop in obj) {     console.log(obj.prop);</code> 这里有一个错误哦~！应该写成obj[prop]的形式。<br>  }<br> obj.prop—-&gt;就相当于obj[“prop”]，因为系统会隐式的把前面的改成后面的这种形式。<br>  这里有一个问题，用对象.prop的话，会访问这个对象上的属性。不过这个对象上并没有prop的属性，所以最后会打印出5个undefined。所以应该写成对象[name]属性的形式。记住哦~！！！</p><p>  这样遍历对象的话会把原型上的属性也会给遍历出来，但是不包括系统自己原型上本来就有的，只是自己手动设的才会连着打印出来的。所以要是只想遍历这个对象本身的属性的话，应该先判断一下是否属于自身的属性，用到的方法就是对象.hasOwnProperty</p><p>还有一个跟hasOwnProperty差不多的方法就是in，他的作用就是看一下对象上有没有这个这个属性，比如看一下对象是否有name的属性，就是：’name’ in obj;属性值必须是字符串形式的。返回值是布尔类型的值。但是有一个缺点就是不管这个属性是不是你本身的，你父亲的他返回值也是true。</p><p>instanceof</p><p>eg:<br><code>function Person() {};  var person = new Person();  person instanceof Person;</code>  返回结果为：true  看person是不是Person构造出来的；但是   person instanceof Object;  返回结果也为：true；   结论：看A的原型链上有没有B的原型，在原型链上的也认为是，所以这是往原型链上找的。</p><p>instanceof 方法检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true，如果不在怎返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错（类似空指针异常）。<br>还有一个方法很像in的方法，他就是instanceof。官方给出的解释是 A对象是不是B构造函数构造出来的。 比如：A insftanceof B。<br>但是官方的解释是远远不够的，只要是在原来对象原型链之上的他的返回结果都是true。所以其实他的意思应该是：看一下A对象的原型链上有没有B的原型，也就是找祖先的，往原型链之上找到。所以instanceof解决了一个问题，就是typeof方法不能精确判断出来的问题。<br>eg：var arr = [] || {};<br>传进去一个变量，这个变量有可能是数组也有可能是对象，如何判断出来；有三种区分方法：</p><ol><li>用constructor可以区分出来<br>[].constructor   返回结果为：function Array() {  {native code}  }<br>var obj = {};<br>obj.constructor   返回结果为：function Object() {  {native code}  }  </li><li>用instanceof可以区分出来<br>[] instanceof Array<br>返回结果为：true<br>var obj = {};<br>obj instanceof Array<br>返回结果为：false</li><li>用toString方法可以区分出来（一般也都是用这种方法区分的）<br>数组、对象等等都有自己的toString方法<br>Object.prototype.toString.call([]);调用数组的toString方法  返回结果为：”[object Array]”<br>Object.prototype.toString.call({});调用对象的toString方法  返回结果为：”[object Object]”<br>Object.prototype.toString.call(123);调用数字的toString方法  返回结果为：”[object Number]”<br>toString方法可以准确区别出来数组和对象。并且在有父子页面的情况下也能准确识别出来，其他的两种方法就不能在子页面中识别出来父页面下类型了。所以一般我们都是用toString方法来区分的。</li></ol><p>深度克隆：遍历对象  for(var prop in obj)</p><pre><code>1. 判断是不是原始值   typeof()  object2. 判断是数组还是对象，有三种方法：instanceof   toString  constructor  一般用toString方法，因为如果在原先的页面上再引入一个页面的话，引入进来的页面中的数组和对象就不符合原先的原则了，而toString方法则不会发生这种引用错误。3. 建立相应的数组或对象递归的方法。(必须找出口)</code></pre><p>`var obj = {<br>  name : ‘abc’,<br>  age : 123,<br>  card : [‘vasa’, ‘master’],<br>  wife : {<br>  name : ‘bcd’,<br>  son : {<br>    name : ‘aaa’<br>  }<br>  }<br>}</p><p>function deepClone(origin, target) {<br>  var target = target || {},<br>      toStr = Object.prototype.toString,<br>      arrStr = “[object Array]”;<br>  for(var prop in origin) {<br>      if(origin.hasOwnProperty(prop)) {<br>  if(origin[prop] !== ‘null’ &amp;&amp; typeof(origin[prop]) == ‘object’) {<br>    if(toStr.call(origin[prop]) == ‘arrStr’){<br>       target[prop] = [];<br>    }else{<br>       target[prop] = {};<br>    }<br>    deepClone(origin[prop], target[prop]);<br>    }else{<br>    target[prop] = origin[prop];<br>    }<br>  }<br>  }<br>  return target;<br>}<br>var target = deepClone(obj);`</p><p>三步运算符：?:<br>  条件判断  ？  是  ： 否  表达式运算之后会返回值<br>条件判断？前面的，条件成立的话执行：前面的运算表达式，条件不成立的话执行：后面的运算表达式。<br>var num = 1 &gt; 0 ? (“10” &gt; “9” ? 1 : 0) : 2;<br>结果为：0   （字符串形式的数字比较是逐位比较ASCII（阿斯克码）表）</p><p>数组<br>字面量 var arr = [];<br>var arr = [,,];  arr的结果为2个undefined。<br>var arr = [1,2,3,,,,7,8]</p><p>系统的构造方法：var arr = new Array(10.2);这样会报错的。只填一位的话会形成稀松数组，也就是var arr = new Array(10);会形成10位值为undefined的数组。还可以溢出读和写。</p><p>数组常用的方法：<br>改变原数组：push,pop,shift,unshift,sort,reverse<br>       splic</p><p>push方法是在数组的最后添加参数，可以添加多位；<br>pop方法是在数组的最后剪切一位出来，并且（）里面不支持添加参数，添加也没啥用，所以每次只能剪切一位出来；<br>shift方法是在数组的最前面剪切一位出来；<br>unshift方法是在数组的最前面添加参数，并且可以添加多位；<br>reverse方法会把原数组逆转顺序。<br>splice()括号里填参数：第一位参数是从第几位开始，第二位参数是截取多少的长度，再往后面填的参数就是在切口处添加的参数，可以无穷多个了。切的刀口就在光标处，一般splice方法用的是添加数组的比较多。而且还可以在负数位开始截取。</p><p>sort方法是给数组按照升序排序的方法，而且是按照字符串阿斯克码进行排序的。所以一般是我们自己给sort()方法设置他的排序方法。<br>1、必须写两个形参   2、看返回值（1）当返回值为负数是，那么前面的数放在前面（2）为正数，那么后面的数在前 （3）为0，则不动<br>   冒泡排序的规则；<br>arr.sort(function(a, b) {<br>if(a &gt; b) {<br>  return 1;<br>}else {<br>  return -1;<br>}<br>});</p><p>简写这个代码的话就是;<br><code>arr.sort(function(a, b) {  return a - b;   升序  return b - a;   降序})</code></p><p>给一个有序的数组，乱序<br><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];arr.sort(function() {  return Math.random() - 0.5;});</code><br>按照对象的年龄升序排列；<br><code>var cheng = {  name : &quot;cheng&quot;,  age : 18,  sex : &#39;male&#39;,  face : &quot;handsome&quot;}var deng = {  name : &quot;deng&quot;,  age : 40,  sex : undefined,  face : &#39;amazing&#39;}var zhang = {  name : &quot;zhang&quot;,  age : 20,  sex : &quot;female&quot;}var arr = [cheng, deng, zhang];arr.sort(function(a, b) {  return a.age - b.age;})</code></p><p>不可改变原数组<br>concat,join—&gt;split,toString,slice  </p><p>concat连接  arr.concat(arr1)  把数组arr1加到数组arr后面。<br>数组的toString是把数组变成字符串。<br>slice(从该位开始截取，截取到该位)<br>join(“-“)方法可以再数组的每一位之间加上-连接成一个字符串。<br>split(“-“)方法可以根据”-“把数组的字符串拆成单个的。可以根据任意的字符串拆分。</p><p>例题：<br><code>var str = &quot;alibaba&quot;;var str1 = &quot;baidu&quot;;var str2 = &quot;tencent&quot;;var str3 = &quot;toutiao&quot;;var str4 = &quot;wangyi&quot;;var str5 = &quot;xiaowang&quot;;var str6 = &quot;nvsheng&quot;;var strFinal = &quot;&quot;;var arr = [str, str1, str2, str3, str4, str5, str6];</code><br>字符串放在栈内存里存储，first in, last out;所以字符串的连接是调用每一个字符串进行连接，效率低下，一般我们把字符串先保存到数组中进行调用的，这样效率更高，因为数组的散列结构。</p><p>类数组 arguments<br>例：<br><code>var obj = {  &quot;0&quot; : &#39;a&#39;,  &quot;1&quot; : &#39;b&#39;,  &quot;2&quot; : &#39;c&#39;,  &quot;length&quot; : 3,  &quot;push&quot; : Array.prototype.push,  &quot;splice&quot; : Array.prototype.splice}</code><br>属性要为索引(数字)属性，必须有length属性，最好加上push方法。</p><p>例题：<br><code>var obj = {  &quot;2&quot; : &#39;a&#39;,  &quot;3&quot; : &#39;b&#39;,  &quot;length&quot; : 2,  &quot;push&quot; : Array.prototype.push}obj.push(&#39;c&#39;);obj.push(&#39;d&#39;);console.log(obj);</code><br>结果为：obj{<br>  “2” : “c”,<br>  “3” : “d”,<br>  “length” : 4,<br>  “push” : Array.prototype.push<br>}</p><p>完美区别各种类型的函数对象</p><p><code>function type(target) {  var ret = typeof(target),  template = {    &quot;[object Array]&quot; : &quot;array - object&quot;,    &quot;[object String]&quot; : &quot;string - object&quot;,    &quot;[object Number]&quot; : &quot;number - object&quot;,    &quot;[object Boolean]&quot; : &quot;boolean - object&quot;,    &quot;[object Object]&quot; : &quot;object - object&quot;  }  if(target === null) {  return &quot;null&quot;;  }else if(ret == &quot;object&quot;) {  var str = Object.prototype.toString.call(target);  return template[str];  }else{  return ret;  }}</code></p><p>数组去重的方法：hash哈希的方法：基于的就是对象的命名规则就是相同的命名会覆盖，所以达到了数组去重的作用。与当年阿里巴巴考的类数组的例题有点儿相似。<br><code>var arr = [1, 2, 3, 4, 1, 3, 4, 2, 4, 5, 6, 4, 0, 0, 0];Array.prototype.unique = function () {  var temp = {},      arr = [],      len = this.length;  for(var i = 0; i &lt; len; i ++){  if(!temp[this[i]]) {    temp[this[i]] = &quot;abc&quot;;    arr.push(this[i]);  }  }  return arr;}</code><br>this[i]代表数组的第i位。随意取名的话“abc”不能换成this[i],因为要是数组里面有undefined或者0等其他为false的值的话，这个去重就失败了。</p><p>this问题的例题：谁调用的this方法this就指向谁。<br><code>var name = &quot;window&quot;;var obj = {  name : &#39;obj&#39;,  say : function (){  console.log(this.name);  }}var fun = obj.say();</code><br>console.log(obj.say);    结果为：obj<br>console.log(obj.say.call(window));    结果为：window<br>console.log(fun());      结果为：window<br>console.log(fun.call(obj));    结果为：obj</p><p>闭包形成的原因：一个函数套着另一个函数，并且必须要把里面的函数保存到最外面函数的外面才能形成闭包的。把里面的函数保存出来不一定非要用return。也可以在外部调用也可以的。例如：<br><code>var obj = {};    function a() {      var aa = 123;      function b() {      console.log(aa);      }      obj.fun = b;    }    a();    obj.fun();</code>    结果就为：123    因为把里面的函数保存到了外部，会形成闭包，所以就能访问到a函数已经销毁的变量。</p><p>1、一个字符串[a-z]组成，请找出该字符串第一个只出现一次的字母<br>2、字符串去重；</p><p>`var str =  “adshqwertyuioonpqwertmyuiopasdfghjklasdfghjklzxcvb”;<br>function sayFirst(target) {<br>  var len = target.length,<br>      count = 0;<br>  for(var i = 0; i &gt; len; i ++) {<br>  if(target) {</p><p>  }<br>  }<br>}`</p><p>企业开发中为了防止出错的，出错的话之后的代码就不会执行了；如果网速不好话，代码里有的数据没有下载完就会报错的；<br>try{}里面的代码有错误的话，如下：不会执行错误代码，而且错误代码下面的正确代码也不会执行了，但是不会报错的。<br>而try里面有错误的话会直接跳到catch里面执行catch里面的代码，catch就是为了容错，而且是返回错误信息的。e可以随便写。<br><code>try{  console.log(&quot;a&quot;);  console.log(b);  console.log(&quot;c&quot;);}catch(e) {  alert(e.name + &quot; : &quot; + e.message);}</code></p><p>Error.name的六种值对应的信息：</p><ol><li>EvalErron:eval()的使用与定义不一致</li><li>RangeErron:数值越界</li><li>ReferenceError:非法或不能识别的引用数值（没定义就使用的原因）</li><li>SyntaxError:发生语法解析错误（代码中有中文的标点符号，在解析是就会报错）</li><li>TypeError:操作书类型错误</li><li>URLError:URL处理函数使用不当</li></ol><p>es5.0严格模式   es3.0 和 es5.0产生冲突的部分，就用es5.0，否则使用es3.0的；严格模式优点是减少了编程错误的发生。</p><p>es5.0的启用：”use strict”可以写在一个函数里，那么就在这个函数里只能使用严格模式了。在严格模式中不能使用with（改变函数作用域）,arguments.callee(代替匿名函数的作用),func.caller（函数执行时才能调用，也是代替匿名函数的作用）等等方法；而且还有变量赋值前必须声明。this必须被赋值，预编译之前局部为undefined，不再是指向window了。拒绝重复属性和参数。</p><p>with()可以改变作用域链，先找括号里面填写的对象的作用域链，没有的话才会找自己的作用域链上的。命名空间的应用，代码简化的作用。但是更改作用域链的话，会使效率降低。</p><p>eval()括号里能把字符串当代码使用。是魔鬼！还可以改变作用域，他还有自己独立的作用域。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Js笔记：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;js笔记 - typeof | parseInt | &amp;amp;&amp;amp; 与运算符 | || 或运算符 | parseFloat | 作用域 | instance of | 练习题~&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://dexinser.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JQuery</title>
    <link href="https://dexinser.github.io/2017/12/jQuery.html"/>
    <id>https://dexinser.github.io/2017/12/jQuery.html</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2022-11-14T16:36:10.427Z</updated>
    
    <content type="html"><![CDATA[<p><strong> JQuery：</strong> <Excerpt in index | 首页摘要></p><p>jQuery是一个非常优秀的js库。现在有一万行以上的代码了，重在他的封装思想，使用方法会用就可以先查先用。移动端有一个zepto的库就是从jQuery中精简来的。因为移动端的网速没有PC端的快、还有就是不稳定。<br><a id="more"></a></p><The rest of contents | 余下全文><h2 id="jQuery笔记"><a href="#jQuery笔记" class="headerlink" title="jQuery笔记"></a>jQuery笔记</h2><p>jQuery是一个非常优秀的js库。现在有一万行以上的代码了，重在他的封装思想，使用方法会用就可以先查先用。移动端有一个zepto的库就是从jQuery中精简来的。因为移动端的网速没有PC端的快、还有就是不稳定。<br>像百度等等的一些比较大的互联网公司一般都会有在网上的jQuery库的，我们可以在网上直接应用他们的jQuery库，可以用src的方法直接引用过来，当然我们也可以下载下来直接在我们的服务器上直接调用。</p><h3 id="简单模仿jQuery的功能："><a href="#简单模仿jQuery的功能：" class="headerlink" title="简单模仿jQuery的功能："></a>简单模仿jQuery的功能：</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span>() &#123;</span><br><span class="line">  function jQuery (<span class="name">selector</span>, content) &#123;</span><br><span class="line">return new jQuery.prototype.init(<span class="name">selector</span>, context)</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.prototype.init = function (<span class="name">selector</span>, context) &#123;</span><br><span class="line">    var DomArray = document.getElementByTagName(<span class="name">selector</span>, context)<span class="comment">;</span></span><br><span class="line">    for(<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; DomArray.length; i ++) &#123;</span></span><br><span class="line">      this[<span class="name">i</span>] = DomArray[<span class="name">i</span>]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.length = DomArray.length<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.prototype.css = function (<span class="name">parm</span>) &#123;</span><br><span class="line">    for (<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; this.length; i ++) &#123;</span></span><br><span class="line">      for () &#123;</span><br><span class="line">        this[<span class="name">i</span>].style[<span class="name">attr</span>] = parm[<span class="name">attr</span>]<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.prototype.init.prototype = jQuery.prototype<span class="comment">;</span></span><br><span class="line">  window.$ = window.jQuery = jQuery<span class="comment">;</span></span><br><span class="line">&#125;)()<span class="comment">;</span></span><br><span class="line">$(<span class="symbol">'div</span>').css(&#123;width: <span class="symbol">'100px</span>', height: <span class="symbol">'100px</span>', background: <span class="symbol">'red</span>'&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这样就能使用我们所写的jQuery实现一般的功能。</p><blockquote><p>init()方法一般在公司里是用来初始化的作用，整个功能的开始或者是主入口。</p></blockquote><h2 id="jQuery的选择元素："><a href="#jQuery的选择元素：" class="headerlink" title="jQuery的选择元素："></a>jQuery的选择元素：</h2><ol><li>$();括号里面和CSS选择一样，注意对选择出的一组元素，一起处理，省略循环，这里在js里是不允许的。</li><li>括号里面可以写elements, selector.等  eg：$(‘.demo’).css(‘background-color’:’red’);单个是这样写的，多个的话就写在花括号里面eg：({backgroundColor:’red’,width:100,height:100px,})</li><li>括号里面可以是 null false undefined</li><li><p>括号里面可以是 function() {}<br>当$()括号里填的是函数function时；<br><code>$(function () {alert(&#39;jQuery load&#39;);});window.onload = function () {alert(&#39;window load&#39;);};</code><br>结果顺序为：先弹出 window  后弹出 jQuery<br>因为jQuery里面是这样写的：<br><code>function $(selector) {if(typeof selector === &#39;function&#39;) { function temp () {   window.setTimeout(selector, 0); } document.addEventListener(&#39;DOMContentLoaded&#39;, temp)}}</code><br>虽然DOMContentLoaded是较window.onload先执行触发的，也就是先执行temp，但是setTimeout加入任务队列中虽然写的是0毫秒立即执行的，但是最快也要4毫秒之后才能执行，也就是说虽然你应该最先执行，但是因为js是单线程，4毫秒之后也就在windo.onload之后才能执行了。但是要是页面上有很多资源需要加载的话，图片或者文件等等那么window.onload就需要加载一些时间了，也就是在4毫秒之后那么setTimeout就会在window.onload之前了。</p></li><li><p>括号里面可以是 上下文context<br>$(selector, context)<br>eg: $(‘div’, ‘span’).css(background: ‘red’)<br>这样就表示是在div里面的span标签执行css操作。</p></li><li>特有的操作；<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span>(<span class="string">'ul li:first'</span>).css(<span class="string">'background'</span>, <span class="string">'red'</span>)；</span><br><span class="line"><span class="symbol">$</span>(<span class="string">'ul li:last'</span>).css(<span class="string">'background'</span>, <span class="string">'red'</span>)；</span><br><span class="line"></span><br><span class="line"><span class="symbol">$</span>(<span class="string">'ul li:eq(0)'</span>).css(<span class="string">'background'</span>, <span class="string">'red'</span>)；</span><br><span class="line"><span class="symbol">$</span>(<span class="string">'ul li'</span>).<span class="keyword">eq</span>(<span class="number">0</span>).css(<span class="string">'background'</span>, <span class="string">'red'</span>)；</span><br><span class="line"></span><br><span class="line"><span class="symbol">$</span>(<span class="string">'ul li:odd'</span>).css(<span class="string">'background'</span>, <span class="string">'red'</span>)；</span><br><span class="line"><span class="symbol">$</span>(<span class="string">'ul li:even'</span>).css(<span class="string">'background'</span>, <span class="string">'red'</span>)；</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[];</span><br><span class="line">arr.filter(<span class="function"><span class="keyword">function</span> <span class="params">(ele, <span class="keyword">index</span>)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  如果第一个元素和索引满足条件，就把这个元素留下来，放到一个新数组中。起到了一个过滤的作用。</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>)</span></span><br><span class="line"><span class="function"><span class="title">jQuery</span>里面也有这个方法。也能起到过滤的作用。</span></span><br><span class="line"><span class="function">$<span class="params">()</span>.<span class="title">filter</span><span class="params">(selectoe\<span class="keyword">function</span>\element\jQuery <span class="keyword">Object</span>)</span></span></span><br><span class="line"><span class="function">$<span class="params">(<span class="string">'ul li'</span>)</span>.<span class="title">filter</span><span class="params">(<span class="string">':even'</span>)</span>.<span class="title">css</span><span class="params">(<span class="string">'background'</span>, <span class="string">'orange'</span>)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>过滤一下是偶数的li执行它。</p></blockquote><p><code>$(&#39;ul li&#39;).filter(function (index) {  index % 4 === 0;}).css(&#39;background&#39;, &#39;orange&#39;);</code></p><h1 id="下面介绍一些再jQuery中常用的方法："><a href="#下面介绍一些再jQuery中常用的方法：" class="headerlink" title="下面介绍一些再jQuery中常用的方法："></a>下面介绍一些再jQuery中常用的方法：</h1><h2 id="not-方法"><a href="#not-方法" class="headerlink" title="not()方法"></a>not()方法</h2><p>not()方法功能正好跟上面的filter()相反。</p><h2 id="has-方法"><a href="#has-方法" class="headerlink" title="has()方法"></a>has()方法</h2><p>has()方法功能<br><code>$(&#39;ul li&#39;).has(&#39;span&#39;).css(&#39;background&#39;, &#39;orange&#39;)</code>  表示的是li标签中有span标签的操作它</p><h2 id="is-方法"><a href="#is-方法" class="headerlink" title="is()方法"></a>is()方法</h2><p>is()方法。他之后就不能再进行链式调用了。因为他返回的结果为boolean类型的。<br><code>$(&#39;ul .demo&#39;).is($(&#39;ul li&#39;).eq(2))</code> 返回的结果为 true，表示的是看前面所选的跟后面的是否相同。</p><h2 id="find-方法"><a href="#find-方法" class="headerlink" title="find()方法"></a>find()方法</h2><p><code>$(&#39;ul&#39;).find(&#39;.demo&#39;).css(&#39;background&#39;, &#39;orange&#39;)</code> 表示的是在ul里面找满足条件的li并进行操作li。跟之前的是不同的。因为他操作的不是最前面的ul了，而是操作的是find找到的满足条件的li。而且通过find()返回的结果里面还有一个prevObject对象，这个是找到这个之前的标签，与end()方法是一样的，可以往上回退到之前的标签。<br><code>$(&#39;ul&#39;).find(&#39;.demo&#39;).prevObject === $(&#39;ul&#39;)</code> 结果为：false  （因为之前是new出来的对象，后面是另一个new出来的另一个对象）</p><h2 id="html-方法"><a href="#html-方法" class="headerlink" title="html()方法"></a>html()方法</h2><p>html()方法,是基于innerHTML的方法的，是获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容。<br><code>$(&#39;ul li&#39;).html();</code>表示的是取出来一个li。   取值取一个，赋值赋一组。<br><code>$(&#39;ul li&#39;).html(&#39;&lt;span style=&quot;color: orange;&quot;&gt;haha&lt;/span&gt;&#39;);</code>表示的是在每一个li标签中都添加了一个span标签</p><h2 id="text-方法"><a href="#text-方法" class="headerlink" title="text()方法"></a>text()方法</h2><p>text()方法，是基于innerTEXT的方法，是得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。hahahahahaahahahhhahhahaha十个li中的文本内容全部返回。<code>$(&#39;ul li&#39;).text(&#39;123&#39;)</code>会把ul下的所有东西都替换了。</p><h2 id="css-方法"><a href="#css-方法" class="headerlink" title=".css()方法"></a>.css()方法</h2><p><code>$(&#39;ul li&#39;).css()</code>当赋值为颜色的时候会把颜色内部转换成RGB形式的。取值取一个，赋值赋一组。</p><h2 id="setAttribute-方法"><a href="#setAttribute-方法" class="headerlink" title=".setAttribute()方法"></a>.setAttribute()方法</h2><p><code>.setAttribute</code><strong>是设置DOM元素上的属性的。DOM上的标签上的特性像id、class等等会与DOM设置的形成一一映射的关系，而属性是你自己设置的所以则没有这种映射关系。</strong></p><h2 id="attr-方法"><a href="#attr-方法" class="headerlink" title=".attr()方法"></a>.attr()方法</h2><p><code>attr()</code>方法,是基于setAttribute()方法的<br><code>$(&#39;ul li&#39;).attr(&#39;data&#39;, &#39;duyi&#39;);</code>  表示的是在每一个li上面都加上了一个属性名称data=”duyi”;<br><code>$(&#39;ul li&#39;).attr(&#39;data&#39;);</code>  结果为一个duyi,这就是取值，取值取一个，赋值赋一组。</p><h2 id="prop-方法"><a href="#prop-方法" class="headerlink" title=".prop()方法"></a>.prop()方法</h2><p>prop()方法，是标签上的特性，才能添加上去的。<br><code>$(&#39;ul li&#39;).prop(&#39;id&#39;, &#39;demo&#39;)</code>,表示在每一个li标签上添加了一个id特性值为demo。<br>再比如表单<code>&lt;input type=&quot;radio&quot; checked=&quot;checked&quot;&gt;</code><br><code>$(&#39;input&#39;).attr(&#39;checked&#39;);</code>当被选中的时候就是checked没有选中的时候就是undefined。但是你不了解的话就不会知道的。但是用prop()方法就不会不了解了，这个点返回值是true或者false。一般表单这个我们都用prop方法。</p><h2 id="next-、prev-方法"><a href="#next-、prev-方法" class="headerlink" title="next()、prev()方法"></a>next()、prev()方法</h2><p>next()的下一个标签   prev()的前一个标签   index()返回这个标签的索引是第几位。<br><code>$(&#39;li&#39;).click(function () {  console.log(this);  console.log($(this).index());})</code></p><p>因为jQuery是链式操作，所以下面的这些方法是有相反的。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">'.box3'</span>).inserBefore( <span class="variable">$(</span><span class="string">'.box1'</span>) );在box1之前加入box3</span><br><span class="line"><span class="variable">$(</span><span class="string">'.box1'</span>).before( <span class="variable">$(</span><span class="string">'.box3'</span>) );同上</span><br><span class="line"></span><br><span class="line"><span class="variable">$(</span><span class="string">'.box3'</span>).appendTo( <span class="variable">$(</span><span class="string">'.wrapper'</span>) );往.wrapper里加入box3</span><br><span class="line"><span class="variable">$(</span><span class="string">'.wrapper'</span>).append( <span class="variable">$(</span><span class="string">'.box3'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="variable">$(</span><span class="string">'.box3'</span>).prependTo( <span class="variable">$(</span><span class="string">'.wrapper'</span>) );往.wrapper之前加入box3</span><br><span class="line"><span class="variable">$(</span><span class="string">'.wrapper'</span>).prepend( <span class="variable">$(</span><span class="string">'.box3'</span>) );</span><br></pre></td></tr></table></figure></p><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h2><p>remove()方法：是把标签移除。</p><h1 id="jQuery中的注册事件方法"><a href="#jQuery中的注册事件方法" class="headerlink" title="jQuery中的注册事件方法"></a>jQuery中的注册事件方法</h1><h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a>bind()方法</h2><p>注册事件bind() （老版本）绑定事件的，可以改变this指向</p><h2 id="on-方法"><a href="#on-方法" class="headerlink" title="on()方法"></a>on()方法</h2><p>on() （新版本）  括号里面传参数是第一个是绑定的事件类型，第二个是绑定事件的方法 on(‘click’, function() {})   第三个参数可以是数组对象，那么传的参数就会在这个绑定on方法的对象上了。第四个参数最重要是可以实现事件委托。<code>$(&#39;.wrapper&#39;).on(&#39;click&#39;, &#39;div&#39;, [{name: &#39;cst&#39;}, &#39;18&#39;], function() {});</code>就相当于给.wrapper下的div加上了绑定事件，事件委托了，就是说不管是不是原来就在.wrapper下的div，因为这是给.wrapper上绑定了事件，会把这个事件直接加到他下面的div中。功能很强大啊！</p><h2 id="off-方法"><a href="#off-方法" class="headerlink" title="off()方法"></a>off()方法</h2><p>alert()会阻塞页面。   off(this) 解除绑定事件，会把调用off事件的所有绑定的事件全部清除。</p><p><code>$(&#39;.wrapper&#39;).on(&#39;click&#39;, function () {alert(0)}).on(&#39;click&#39;, function () {alert(1)});</code><br><code>$(&#39;.wrapper&#39;).off(&#39;click&#39;)</code><br><strong>怎么绑定的就怎么来解绑。</strong></p><h2 id="点赞有次数限制"><a href="#点赞有次数限制" class="headerlink" title="点赞有次数限制"></a>点赞有次数限制</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">good</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'赞'</span>)；</span><br><span class="line">  <span class="keyword">if</span> (++times === <span class="number">10</span>) &#123;</span><br><span class="line">$(<span class="keyword">this</span>).off(<span class="string">'click'</span>, good);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">'.wrapper'</span>).on(<span class="string">'click'</span>, good);</span><br><span class="line">$(<span class="string">'.wrapper'</span>).one(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>on()方法不仅可以绑定系统固有的事件，还可以绑定自定义事件。自定义事件可以通过trigger来触发。</strong></p><h2 id="offsetWidth-方法"><a href="#offsetWidth-方法" class="headerlink" title="offsetWidth()方法"></a>offsetWidth()方法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'wp'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(oDiv.offsetWidth);    oDiv.offsetWidth()这个方法显示的就是“content + padding + border”</span><br><span class="line">oDiv.innerWidth   这个显示的是“content + padding” </span><br><span class="line">oDiv.outerWidth()</span><br></pre></td></tr></table></figure><p>传参数，参数是true的时候会加上margin，没有参数就没有margin的值   这个显示的是“content + padding + border + margin”<br><code>$(&#39;.content&#39;).offset()</code>这个方法会返回一个对象，这个对象里面有top:  和  left:   并且值是与浏览器边框的距离值。<br><code>$(&#39;.content&#39;).position()</code>这个方法也会返回一个对象，这个对象里面的top:   和   left:   的值是与最近的父级元素的距离，父级元素要有相对定位或者绝对定位等等的可以让子级找到的属性。   </p><h2 id="创建dom方法"><a href="#创建dom方法" class="headerlink" title="创建dom方法"></a>创建dom方法</h2><p>$(‘<div> div </div>‘)可以这样创建一个div<br>$(‘</div>‘)这样也可以，只不过这样就不能填写里面的内容了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; JQuery：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;jQuery是一个非常优秀的js库。现在有一万行以上的代码了，重在他的封装思想，使用方法会用就可以先查先用。移动端有一个zepto的库就是从jQuery中精简来的。因为移动端的网速没有PC端的快、还有就是不稳定。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://dexinser.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之V8引擎</title>
    <link href="https://dexinser.github.io/2017/12/JavaScript%E4%B9%8BV8%E5%BC%95%E6%93%8E.html"/>
    <id>https://dexinser.github.io/2017/12/JavaScript之V8引擎.html</id>
    <published>2017-12-12T16:00:00.000Z</published>
    <updated>2022-11-14T16:35:56.862Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JavaScript之V8引擎</strong>     <Excerpt in index | 首页摘要></p><p>V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。<br><a id="more"></a></p><The rest of contents | 余下全文><p>V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。<br>V8在执行之前将JavaScript代码编译成机器码让计算机识别执行，而非字节码或者直译它，以此来提升效能，JavaScript程序与V8引擎的速度可以媲美二进制编译。在高性能JavaScript一书中作者有比较V8引擎与其他语言的执行速度，作者列成了图表很清楚的显示出JavaScript引擎V8不俗的执行速度。</p><p>V8是Google Chrome浏览器内置的JavaScript脚本引擎。<br>Google Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。<br>V8引擎编译和执行JavaScript源代码。<br>速度是V8引擎追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码 + 解释器”的引擎，优势不言而喻。<br>V8引擎的团队说Chrome对脚本的解析和执行速度是Firefox和Safari的10倍，是IE的56倍。当然了，自夸自家的瓜甜，都是这样的嘛~最近不是新出了Safari又比Google Chrome快了80%的速度吗~但是只是因为Safari更新的比较快，优化了最新的ES6，所以与之前未做优化的Chrome相比快了不少~也是真能吹牛哈~</p><hr><p>正是由于V8的高性能，所以基于nodejs开发的引擎就是V8引擎。</p><hr><p>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。V8的JavaScript渲染引擎亮点在于更快速更强壮的JavaScript解析。V8是一个非常反传统的JavaScript引擎，它能够在后台动态的对JS的对象进行分类——一个在其他高级语言中很常见但JS本身不支持的特性。V8对JS的解析不是基于反复loop源代码进行解释而是直接将JS代码编译成机器码运行。换句话说，V8引擎实际上可以看做是JS的扩展和编译器——而传统上类似于JS的解释型语言恰恰是不需要编译器的。最后，高级语言的内存管理效能一直是决定其运行效率的重要因素，而当前的JS虚拟机在这方面做的比较基本，对内存的回收也非常保守。V8使用的是非常强势的内存管理策略，一切在运行堆栈里无用的数据都会被强行回收，从而可以大大提高JS代码的运行效率。<br>在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。</p><p>和Mozilla的SpiderMonkey一样，Google Chrome浏览器的JavaScript引擎Google V8也是一个开源的独立引擎，可内嵌于任何C++工程之中。</p><blockquote><p>速度是V8追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。在SunSpider测试中，V8的综合表现是最好的。据说Mozilla正在开发的TraceMonkey比V8还要快20%左右，可惜尚未完工。</p></blockquote><h1 id="JavaScript的发展"><a href="#JavaScript的发展" class="headerlink" title="JavaScript的发展"></a>JavaScript的发展</h1><blockquote><p>Netscape Navigator 在 90 在年代中期对 JavaScript 进行了集成，这让网页开发人员对 HTML 页面中诸如 form 、frame 和 image 之类的元素的访问变得非常容易。由此 JavaScript 很快成为了用于定制控件和添加动画的工具，到 90 年代后期的时候，大部分的 JavaScript 脚本仅仅完成像“根据用户的鼠标动作把一幅图换成另一幅图”这样简单的功能。</p></blockquote><blockquote><p>随着最近 AJAX 技术的兴起，JavaScript 现在已经变成了实现基于 web 的应用程序（例如我们自己的 Gmail）的核心技术。JavaScript 程序从聊聊几行变成数百 KB 的代码。JavaScript 被设计于完成一些特定的任务，虽然 JavaScript 在做这些事情的时候通常都很高效，但是性能已经逐渐成为进一步用 JavaScript 开发复杂的基于 web 的应用程序的瓶颈。</p></blockquote><blockquote><p>V8 是一个全新的 JavaScript 引擎，它在设计之初就以高效地执行大型的 JavaScript 应用程序为目的。在一些性能测试中，V8 比 Internet Explorer 的 JScript 、Firefox 中的 SpiderMonkey 以及 Safari 中的 JavaScriptCore 要快上数倍。如果你的 web 程序的瓶颈在于 JavaScript 的运行效率，用 V8 代替你现在的 JavaScript 引擎很可能可以提升你的程序的运行效率。具体会有多大的性能提升依赖于程序执行了多少 JavaScript 代码以及这些代码本身的性质。比如，如果你的程序中的函数会被反复执行很多遍的话，性能提升通常会比较大，反过来，如果代码中有很多不同的函数并且都只会被调用一次左右，那么性能提升就不会那么明显了。其中的原因在你读过这份文档余下的部分之后就会明白了。</p></blockquote><h1 id="V8-的性能提升主要来自三个关键部分："><a href="#V8-的性能提升主要来自三个关键部分：" class="headerlink" title="V8 的性能提升主要来自三个关键部分："></a>V8 的性能提升主要来自三个关键部分：</h1><ol><li>快速属性访问</li><li>动态机器码生成</li><li>高效的垃圾收集</li></ol><h2 id="快速属性访问"><a href="#快速属性访问" class="headerlink" title="快速属性访问"></a>快速属性访问</h2><p>JavaScript 是一门动态语言，属性可以在运行时添加到或从对象中删除。这意味着对象的属性经常会发生变化。大部分 JavaScript 引擎都使用一个类似于字典的数据结构来存储对象的属性，这样每次访问对象的属性都需要进行一次动态的字典查找来获取属性在内存中的位置。这种实现方式让 JavaScript 中属性的访问比诸如 Java 和 Smalltalk 这样的语言中的成员变量的访问慢了许多。成员变量在内存中的位置离对象的地址的距离是固定的，这个偏移量由编译器在编译的时候根据对象的类的定义决定下来。因此对成员变量的访问只是一个简单的内存读取或写入的操作，通常只需要一条指令即可。</p><p>为了减少 JavaScript 中访问属性所花的时间，V8 采用了和动态查找完全不同的技术来实现属性的访问：动态地为对象创建隐藏类。这并不是什么新的想法，基于原型的编程语言 Self 就用 map 来实现了类似的功能（参见 An Efficient Implementation of Self, a Dynamically-Typed Object-Oriented Language Based on Prototypes ）而且JavaScript在创建之初因为是赶时间赶出来的（10天的时间，而且还是Brendan Eich为了应付公司安排的任务的~），所以也正是借鉴了很多语言的长处，也就是上面所说的self语言和C语言等等（有一句话说的好：与其说我爱JavaScript，不如说我恨她；她是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：“她的优秀之处并非原创，她的原创之处并不优秀”）。在 V8 里，当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。</p><p>下面我们用一个简单的 JavaScript 函数来加以说明：</p><p><code>function Point(x, y) {    this.x = x;    this.y = y;}</code></p><p>当 new Point(x, y) 执行的时候，一个新的 Point 对象会被创建出来。如果这是 Point 对象第一次被创建，V8 会为它初始化一个隐藏类，不妨称作 C0。因为这个对象还没有定义任何属性，所以这个初始类是一个空类。到这个时候为止，对象 Point 的隐藏类是 C0。</p><p>map_trans_a<br>执行函数 Point 中的第一条语句（this.x = x;）会为对象 Point 创建一个新的属性 x。此时，V8 会：<br>在 C0 的基础上创建另一个隐藏类 C1，并将属性 x 的信息添加到 C1 中：这个属性的值会被存储在距 Point 对象的偏移量为 0 的地方。<br>在 C0 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 x 之后能够找到 C1 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C1。</p><ol><li>map_trans_b<br>执行函数 Point 中的第二条语句（this.y = y;）会添加一个新的属性 y 到对象 Point 中。同理，此时 V8 会：<br>在 C1 的基础上创建另一个隐藏类 C2，并在 C2 中添加关于属性 y 的信息：这个属性将被存储在内存中离 Point 对象的偏移量为 1 的地方。<br>在 C1 中添加适当的类转移信息，使得当有另外的以其为隐藏类的对象在添加了属性 y 之后能够找到 C2 作为新的隐藏类。此时对象 Point 的隐藏类被更新为 C2。</li><li>map_trans_c<br>咋一看似乎每次添加一个属性都创建一个新的隐藏类非常低效。实际上，利用类转移信息，隐藏类可以被重用。下次创建一个 Point 对象的时候，就可以直接共享由最初那个 Point 对象所创建出来的隐藏类。例如，如果又一个 Point 对象被创建出来了：<br>一开始 Point 对象没有任何属性，它的隐藏类将会被设置为 C0。<br>当属性 x 被添加到对象中的时候，V8 通过 C0 到 C1 的类转移信息将对象的隐藏类更新为 C1 ，并直接将 x 的属性值写入到由 C1 所指定的位置（偏移量 0）。<br>当属性 y 被添加到对象中的时候，V8 又通过 C1 到 C2 的类转移信息将对象的隐藏类更新为 C2，并直接将 y 的属性值写入到由 C2 所指定的位置（偏移量 1）。</li></ol><p>尽管 JavaScript 比通常的面向对象的编程语言都要更加动态一些，然而大部分的 JavaScript 程序都会表现出像上述描述的那样的运行时高度结构重用的行为特征来。使用隐藏类主要有两个好处：属性访问不再需要动态字典查找了；为 V8 使用经典的基于类的优化和内联缓存技术创造了条件。</p><h2 id="动态机器码生成"><a href="#动态机器码生成" class="headerlink" title="动态机器码生成"></a>动态机器码生成</h2><p>V8 在第一次执行 JavaScript 代码的时候会将其直接编译为本地机器码，而不是使用中间字节码的形式，因此也没有解释器的存在。属性访问由内联缓存代码来完成，这些代码通常会在运行时由 V8 修改为合适的机器指令。</p><p>在第一次执行到访问某个对象的属性的代码时，V8 会找出对象当前的隐藏类。同时，V8 会假设在相同代码段里的其他所有对象的属性访问都由这个隐藏类进行描述，并修改相应的内联代码让他们直接使用这个隐藏类。当 V8 预测正确的时候，属性值的存取仅需一条指令即可完成。如果预测失败了，V8 会再次修改内联代码并移除刚才加入的内联优化。</p><p>例如，访问一个 Point 对象的 x 属性的代码如下：</p><p>point.x</p><p>在 V8 中，对应生成的机器码如下：</p><p><code>; ebx = the point objectcmp [ebx, &lt;hidden class offset&gt;], &lt;cached hidden class&gt;jne &lt;inline cache miss&gt;mov eax, [ebx, &lt;cached x offset&gt;]</code></p><p>如果对象的隐藏类和缓存的隐藏类不一样，执行会跳转到 V8 运行系统中处理内联缓存预测失败的地方，在那里原来的内联代码会被修改以移除相应的内联缓存优化。如果预测成功了，属性 x 的值会被直接读出来。</p><p>当有许多对象共享同一个隐藏类的时候，这样的实现方式下属性的访问速度可以接近大多数动态语言。使用内联缓存代码和隐藏类实现属性访问的方式和动态代码生成和优化的方式结合起来，让大部分 JavaScript 代码的运行效率得以大幅提升。</p><h2 id="高效的垃圾回收机制"><a href="#高效的垃圾回收机制" class="headerlink" title="高效的垃圾回收机制"></a>高效的垃圾回收机制</h2><p>V8 会自动回收不再被对象使用的内存，这个过程通常被称为“垃圾收集（Garbage Collection）”。为了保证快速的对象分配和缩短由垃圾收集造成的停顿，并杜绝内存碎片，V8 使用了一个 stop-the-world, generational, accurate 的垃圾收集器，换句话说，V8 的垃圾收集器：</p><ol><li>在执行垃圾回收的时候会中断程序的执行。</li><li>大部分情况下，每个垃圾收集周期只处理整个对象堆的一部分，这让程序中断造成的影响得以减轻。</li><li>总是知道内存中所有的对象和指针所在的位置，这避免了非 accurate 的垃圾收集器中普遍存在的由于错误地把对象当作指针而造成的内存溢出的情况。</li></ol><p>在 V8 中，对象堆被分成两部分：用于为新创建的对象分配空间的部分和用于存放在垃圾收集周期中生存下来的那些老的对象的部分。如果一个对象在垃圾收集的过程中被移动了，V8 会更新所有指向这个对象的指针到新的地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JavaScript之V8引擎&lt;/strong&gt;     &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;V8是由拉里·佩奇、谢尔盖·布林创办的以搜索引擎和线上广告技术闻名、全球最大的网络公司Google研发的开源JavaScript浏览器引擎，用于Google Chrome中。&lt;br&gt;
    
    </summary>
    
      <category term="认知提升" scheme="https://dexinser.github.io/categories/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="JavaScript" scheme="https://dexinser.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>编程方法小汇总</title>
    <link href="https://dexinser.github.io/2017/12/important%20Ideas.html"/>
    <id>https://dexinser.github.io/2017/12/important Ideas.html</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2022-11-14T16:35:42.039Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 编程方法小汇总：</strong> <Excerpt in index | 首页摘要></p><p>深度克隆：遍历对象。 &amp; 封装Ajax方法  &amp; 模拟虚拟DOM的实现方法。<br><a id="more"></a></p><The rest of contents | 余下全文><h2 id="深度克隆：遍历对象-for-var-prop-in-obj"><a href="#深度克隆：遍历对象-for-var-prop-in-obj" class="headerlink" title="深度克隆：遍历对象  for(var prop in obj)"></a>深度克隆：遍历对象  for(var prop in obj)</h2><pre><code>1、判断是不是原始值   typeof()  object2、判断是数组还是对象，有三种方法：instanceof   toString  constructor  一般用toString方法，因为如果在原先的页面上再引入一个页面的话，引入进来的页面中的数组和对象就不符合原先的原则了，而toString方法则不会发生这种引用错误。3、建立相应的数组或对象递归的方法。(必须找出口)</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name : <span class="string">'abc'</span>,</span><br><span class="line">  age : <span class="number">123</span>,</span><br><span class="line">  card : [<span class="string">'vasa'</span>, <span class="string">'master'</span>],</span><br><span class="line">  wife : &#123;</span><br><span class="line">name : <span class="string">'bcd'</span>,</span><br><span class="line">son : &#123;</span><br><span class="line">  name : <span class="string">'aaa'</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = target || &#123;&#125;,</span><br><span class="line">toStr = <span class="built_in">Object</span>.prototype.toString,</span><br><span class="line">arrStr = <span class="string">"[object Array]"</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> origin) &#123;</span><br><span class="line"><span class="keyword">if</span>(orgin.hasOwnProperty(prop)) &#123;</span><br><span class="line">  <span class="keyword">if</span>(origin[prop] !== <span class="string">'null'</span> &amp;&amp; <span class="keyword">typeof</span>(origin[prop]) == <span class="string">'object'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(toStr.call(origin[prop]) == <span class="string">'arrStr'</span>)&#123;</span><br><span class="line">   target[prop] = [];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   target[prop] = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">deepClone(origin[prop], target[prop]);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">target[prop] = origin[prop];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line">deepClone(obj);</span><br></pre></td></tr></table></figure><h2 id="封装Ajax方法："><a href="#封装Ajax方法：" class="headerlink" title="封装Ajax方法："></a>封装Ajax方法：</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Ajax(method, url, flag, data, callBack) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">app</span> = null;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="keyword">app</span> = new <span class="keyword">window</span>.XMLHttpRequest();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">app</span> = new <span class="keyword">window</span>.ActiveXObject('Microsoft.XMLHTTP');</span><br><span class="line">  &#125;</span><br><span class="line">  method = method.toUpperCase();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(method === 'GET') &#123;</span><br><span class="line">    <span class="keyword">app</span>.<span class="keyword">open</span>(method, url + '?' + data, flag);</span><br><span class="line">    <span class="keyword">app</span>.send();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method === '<span class="keyword">POST</span>') &#123;</span><br><span class="line">    <span class="keyword">app</span>.<span class="keyword">open</span>(method, url, flag);</span><br><span class="line">    <span class="keyword">app</span>.setRequestHeader('Content-<span class="keyword">type</span>', 'application/x-www-<span class="keyword">form</span>-urlencoded');</span><br><span class="line">    <span class="keyword">app</span>.send(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">app</span>.onreadystatechange = function() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">app</span>.readyState === 4) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">app</span>.status === 200) &#123;</span><br><span class="line">  callBack(<span class="keyword">app</span>.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  alert('<span class="keyword">error</span>');</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vue重要思想（借鉴React）中的虚拟DOM（真实DOM用js实现的方式），极大的减少了浏览器页面切换间的刷新次数。创新的思想！</strong><br>真实实现方法是用：vue.render()函数中的h()函数来实现的！</p><h2 id="模拟虚拟DOM的实现方法："><a href="#模拟虚拟DOM的实现方法：" class="headerlink" title="模拟虚拟DOM的实现方法："></a>模拟虚拟DOM的实现方法：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vElement</span>(<span class="params">tagName,prop,children</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> vElement))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> vElement(tagName,prop,children);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(prop) === <span class="string">"[object Array]"</span>) &#123;</span><br><span class="line">    children = prop;</span><br><span class="line">    prop = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.tagName = tagName;</span><br><span class="line">  <span class="keyword">this</span>.children = children;</span><br><span class="line">  <span class="keyword">this</span>.prop = prop;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child, index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(child <span class="keyword">instanceof</span> vElement) &#123;</span><br><span class="line">count += child.count;</span><br><span class="line">    &#125;</span><br><span class="line">    count ++;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br><span class="line">vElement.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName);</span><br><span class="line">  <span class="keyword">var</span> children = <span class="keyword">this</span>.children;</span><br><span class="line">  <span class="keyword">var</span> prop = <span class="keyword">this</span>.prop;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> prop)&#123;</span><br><span class="line">    <span class="keyword">var</span> curProp = prop[item];</span><br><span class="line">    el.setAttribute(item, curProp);</span><br><span class="line">  &#125;</span><br><span class="line">  children.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">child,index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(child <span class="keyword">instanceof</span> vElement)&#123;</span><br><span class="line"><span class="keyword">var</span> childDom = child.render();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">var</span> childDom = <span class="built_in">document</span>.createTextNode(child);</span><br><span class="line">    &#125;</span><br><span class="line">    el.appendChild(childDom);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dom = vElement(<span class="string">"div"</span>,&#123;<span class="attr">class</span>: <span class="string">"demo"</span>, <span class="attr">id</span>:<span class="string">"demo1"</span>&#125;,[<span class="string">"hello world"</span>,vElement(<span class="string">"p"</span>,&#123;<span class="attr">class</span>:<span class="string">"demo2"</span>&#125;,[<span class="string">"我是p标签"</span>])]);</span><br><span class="line">dom.render();</span><br></pre></td></tr></table></figure><p>结果为：渲染出了两个dom数节点；分别为：<br><code>&lt;div class=&quot;demo&quot; id=&quot;demo1&quot;&gt;  &lt;p class=&quot;demo2&quot;&gt;我是p标签&lt;/p&gt;&lt;/div&gt;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 编程方法小汇总：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;深度克隆：遍历对象。 &amp;amp; 封装Ajax方法  &amp;amp; 模拟虚拟DOM的实现方法。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://dexinser.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之DOM</title>
    <link href="https://dexinser.github.io/2017/12/DOM.html"/>
    <id>https://dexinser.github.io/2017/12/DOM.html</id>
    <published>2017-12-10T16:00:00.000Z</published>
    <updated>2022-11-14T16:34:58.871Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 浏览器之DOM：</strong> <excerpt in index | 首页摘要></excerpt></p><p>DOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="DOM—-gt-Document-Object-Model"><a href="#DOM—-gt-Document-Object-Model" class="headerlink" title="DOM—&gt;Document Object Model"></a>DOM—&gt;Document Object Model</h2><p>DOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。<br>DOM不能操作CSS！！！DOM修改CSS的是通过改变HTML间接改变CSS的。改变不了CSS行间样式，改变的是HTML。</p><p>DOM之后一些成组出现的东西都是类数组的形式。</p><p>每一个词条就是一个query。每个query都是人工自己写的。因为商家都追求不平凡，要和别家的有区分，绚丽一点儿的。</p><p><code>var div = document.getElementsByTagName(&#39;div&#39;)[0];div.style.width = &quot;100px&quot;;div.style.height = &quot;100px&quot;;div.style.backgroundColor = &quot;red&quot;;在div上永久绑定一个方法，每次点击都变色。var count = 0;div.onclick = function () {  count ++;  if(count % 2 == 1) {    this.style.background = &quot;green&quot;;  }else{    this.style.background = &quot;red&quot;;  }}</code></p><p>鼠标监控：<br><code>document.onkeydown = function(e) {  switch(e.which) {    case 37:      div.style.left = perseInt(div.style.left) - speed + &#39;px&#39;;    case 38:      div.style.top = perseInt(div.style.top) + speed + &#39;px&#39;;    case 39:      div.style.left = perseInt(div.style.left) + speed + &#39;px&#39;;    case 40:      div.style.top = perseInt(div.style.top) - speed + &#39;px&#39;;  }}</code></p><h2 id="对节点的增删改查"><a href="#对节点的增删改查" class="headerlink" title="对节点的增删改查"></a>对节点的增删改查</h2><p>查<br>查看元素节点<br>document代表整个文档<br>document.getElementById() //元素id 在Ie8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素<br>.getElementsByTagName() // 标签名<br>getElementByName(); //，需注意，只有部分标签name可生效（表单，表单元素，img，iframe）<br>.getElementsByClassName() // 类名 -&gt; ie8和ie8以下的ie版本中没有，可以多个class一起<br>.querySelector() // css选择器   在ie7和ie7以下的版本中没有<br>.querySelectorAll() // css选择器 在ie7和ie7以下的版本中没有<br>但是他和querySelector这两个方法不常用，因为这两个方法不是实时的，静态的。因为js语言就是实时的，后期只要操作HTML就会重新执行一下页面，所以效率低，但是执行的是实时的。</p><h2 id="DOM结构树-–-gt-一系列继承关系。"><a href="#DOM结构树-–-gt-一系列继承关系。" class="headerlink" title="DOM结构树  –&gt; 一系列继承关系。"></a>DOM结构树  –&gt; 一系列继承关系。</h2><p>Node也是一个构造函数，他是最顶头的那个函数对象。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span>   就是<span class="selector-tag">HTMLDocument</span></span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span>    就是<span class="selector-tag">Document</span></span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span>   就是<span class="selector-tag">Node</span></span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span>   就是<span class="selector-tag">EventTarget</span>   这是一个事件</span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span><span class="selector-class">.__proto__</span>   就是系统上的<span class="selector-tag">Object</span>的原型，最终都会追溯到系统上的__<span class="selector-tag">proto__</span></span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.documentElement</span>   代表的就是<span class="selector-tag">HTML</span>标签</span><br><span class="line"><span class="selector-tag">Document</span>  <span class="selector-tag">--</span>&gt; <span class="selector-tag">HTMLDocument</span>.</span><br><span class="line"><span class="selector-tag">document</span>代表的是整个页面文档。<span class="selector-tag">Document</span>原型链</span><br></pre></td></tr></table></figure></p><ol><li>getElementById方法定义在Document.prototype上，即Element节点上不能使用。</li><li>getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element)</li><li>getElementsByTagName方法定义在Document.prototype 和 Element.prototype上</li><li>HTMLDocument.prototype定义了一些常用的属性，body,head,分别指代HTML文档中的<body><head><meta name="generator" content="Hexo 3.9.0">标签。</head></body></li><li>Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代<html>元素</html></li><li>getElementsByClassName、querySelectorAll、querySelector在Document,Element类中均有定义</li></ol><p><code>&lt;div&gt;&lt;span&gt;1&lt;/span&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;</code><br><code>var div = document.getElementsByTagName(&#39;div&#39;)[0];</code><br><code>var span = div.getElementsByTagName(&#39;span&#39;)[0];</code><br>在开发的时候也是先选中父级，然后在父级下选择要选择的子级。</p><h2 id="节点的类型"><a href="#节点的类型" class="headerlink" title="节点的类型"></a>节点的类型</h2><p>元素节点   —— 1<br>属性节点   —— 2<br>文本节点   —— 3<br>注释节点   —— 8<br>document  —— 9<br>DocumentFragment  ——  11 （文档碎片节点）<br>获取节点类型   nodeType </p><h2 id="遍历节点树："><a href="#遍历节点树：" class="headerlink" title="遍历节点树："></a>遍历节点树：</h2><p> parentNode -&gt; 父节点  每个节点只有一个父节点(最顶端的parentNode为#document。再往上就是null);<br> childNodes -&gt; 子节点们<br> firstChild -&gt; 第一个子节点<br> lastChild -&gt; 最后一个子节点<br> nextSibling-&gt;后一个兄弟元素<br> previousSibling-&gt;前一个兄弟元素</p><p>所说的IE不兼容说的都是IE9以下的。IE10以上都兼容W3C标准了。<br>基于元素节点树的遍历<br>parentElement -&gt; 返回当前元素的父元素节点 (IE不兼容)<br>children -&gt; 只返回当前元素的元素子节点<br>node.childElementCount  === node.children.length当前元素节点的子元素节点个数(IE不兼容)<br>firstElementChild -&gt; 返回的是第一个元素节点(IE不兼容)<br>lastElementChild -&gt; 返回的是最后一个元素节点(IE不兼容)<br>nextElementSibling / previousElementSibling -&gt;返回后一个/前一个兄弟元素节点（IE不兼容)</p><h2 id="节点的四个属性"><a href="#节点的四个属性" class="headerlink" title="节点的四个属性"></a>节点的四个属性</h2><p>nodeName<br>元素的标签名，以大写形式表示,只读<br>nodeValue<br>Text节点或Comment节点的文本内容,可读写<br>nodeType（必须记住，很重要的！）<br>该节点的类型，只读<br>attributes<br>Element 节点的属性集合,比如：<div id="only" class="demo"></div>  div.attributes取出来一个集合放到一个类数组里面。 可以改变值div.attributes[0].value = ‘abc’; 能赋值能改值，只能改属性值，也就是更改id的值。</p><p>节点的一个方法  Node.hasChildNodes();   有没有子节点，返回结果是false或者true。</p><h2 id="DOM基本操作："><a href="#DOM基本操作：" class="headerlink" title="DOM基本操作："></a>DOM基本操作：</h2><p>增<br><code>document.createElement();document.createTextNode();document.createComment();document.createDocumentFragment();</code><br>插<br><code>PARENTNODE.appendChild();PARENTNODE.insertBefore(a, b);</code><br>例如：页面中有<code>&lt;div&gt;</code><br><code>&lt;span&gt;&lt;/span&gt;</code><br><code>&lt;/div&gt;</code><br><code>var str = document.createElement(&#39;strong&#39;);</code><br><code>var div = document.getElementsByTagName(&#39;div&#39;)[0];</code><br><code>div.insertBefore(str, span)</code><br>就是把创建的strong标签插入到div里面的span之前。</p><p>删除标签<br><code>div.removeChild();</code>   其实是剪切,先找到要删除的标签的父级，然后用的是父级删除其中子级的标签功能，一般都用的是这个，因为想用的时候，如果还保存着就还可以找到。真正的删除是用对象<code>.remove();</code>   这是新出的方法，原先没有的。这个是真正的删除了，就再也找不到了。</p><p>替换标签也是父级调用，<code>parentNode.replaceChild(new, origin);</code>用新的去替换久的。被替换的标签不是被删除了，而是被剪切出来了。</p><p><code>div.appendChild(p)</code>,在div标签中加上一些内容或者标签等等。</p><h2 id="Element节点的一些属性"><a href="#Element节点的一些属性" class="headerlink" title="Element节点的一些属性"></a>Element节点的一些属性</h2><p><code>innerHTML</code>  这个可以获取标签中的内容。不是追加，是可以覆盖原先的内容的，但是可以用+=的方法追加内容。还可以改变CSS样式的，只要写入就能使用。<br><code>innerText(火狐不兼容) / textContent(老版本IE不好使)</code>   可取可赋值。但是这个方法一定要慎重的去用。因为会把原先的内容给覆盖的。</p><h2 id="Element节点的一些方法"><a href="#Element节点的一些方法" class="headerlink" title="Element节点的一些方法"></a>Element节点的一些方法</h2><p><code>ele.setAttribute();</code> 设置原生DOM上的属性 例如：<br><code>div.setArrtibute(&#39;id&#39;,&#39;only&#39;)</code>   这表示在div上加上id属性。还可以加上一些没有的属性，也就是人为加上去的属性。就比如在标签上人为设置一个属性，data-log=’0’; 这个认为加上的属性是用来计算数据量的，算流量的，看这些流量从哪些网站分流出来的，计算给钱。   取data-log值就是：  <code>div.getAttribute(&#39;data-log&#39;);</code></p><p><code>ele.getAttribute();</code> 取原生DOM上的属性<br><code>div.getArrtibute();</code>取出行间属性的值。</p><h2 id="日期对象Date"><a href="#日期对象Date" class="headerlink" title="日期对象Date();"></a>日期对象Date();</h2><p>先  <code>var date = new Date();</code><br>然后就能调用Date()方法的一些方法。<br><code>date.getDate();</code> 从Data对象中返回一个月中的某一天 （1-31）  <code>date.getDay();</code>   从Data对象返回一周中的某一天（0-6）<br><code>date.getMonth();</code> 从Data对象返回月份（0-11）<br><code>date.getFullYear();</code>  从Data对象以四位数字返回年份（后来才有的方法）<br><code>date.getYear();</code>  请使用<code>data.getFullYear()</code>方法：一开始就有的方法。只不过这个方法有一个缺点，就是它是用六位表示年月日的。95.03.17；到二千年的时候就不够用了。所以才有了上面的那个完整表示的方法。这就是千年虫问题的出现。当然肯定还有万年虫，不过这个就不是我们需要考虑的问题了，离我们太遥远了~~<br><code>date.getHours();</code>   返回Data对象的小时（0-23）<br><code>date.getMinutes();</code>   返回Data对象的分钟（0-59）<br><code>date.getSeconds();</code>   返回Data对象的秒数（0-59）<br><code>date.getMillseconds();</code>  返回Data对象的毫秒数（0-999）<br><code>date.getTime();</code>    返回1970年1月1日至今的毫秒数（这个方法是最常用的，把耶稣出生的那一年当做人类的纪元年，计算机的纪元年就是1970.01.01，所有的计算机和手机的时间的计算都是根据计算机纪元时间来换算出来的。重点是：这个方法能帮我们算时间差，每个功能用的时间差就是根据这个方法来计算的）<br><code>date.getTimezoneOffset();</code>   返回本地时间与格林威治标准时间（GMT）的分钟差<br><code>date.getUTCDate();</code>    根据世界时从Data对象返回月中的一天（1-31）<br><code>date.getUTCDay();</code>   根据世界时从Data对象返回月份（0-6）<br><code>date.getUTCMonth();</code>  根据世界时从Data对象返回月份（0-11）<br><code>date.getUTCFullYear();</code> 根据世界时从Data对象返回四位数的年份<br><code>date.getUTCHours();</code>  根据世界时返回Data对象的小时（0-23）<br><code>date.getUTCMiutes();</code>  根据世界时返回Data对象的分钟（0-59）<br><code>date.getUTCSeconds();</code>  根据世界时返回Date对象的秒钟（0-59）<br><code>date.getUTCMillseconds();</code> 根据世界时返回Date对象的毫秒（0-999）<br><code>date.parse();</code>   返回1970年1月1日午夜到指定日期（字符串）的毫秒数<br>人为设置一个时间点，到设置好的时间点执行一个功能，比如淘宝上的定时抢购，就是到达人为设置的时间点之后立即执行函数功能。<br><code>date.setDate();</code>   设置Date对象中月的某一天（1-31）<br><code>date.setMonth();</code>   设置Date对象中月份（0-11）<br><code>date.setFullYear();</code>  设置Date对象中的年份（四位数字）<br><code>date.setYear();</code>     请使用setFullYear()方法代替<br><code>date.setHours();</code>    设置Date对象中的小时（0-23）<br><code>date.setMinutes();</code>  设置Date对象中的分钟（0-59）<br><code>date.setSeconds();</code>    设置Date对象中的秒钟（0-59）<br><code>date.setMillseconds();</code>  设置Date对象中的毫秒（0-999）<br><code>date.setTime();</code>      以毫秒设置Date对象<br><code>date.toSource();</code>    返回该对象的源代码<br><code>date.toString();</code>   把Date对象转换为字符串<br><code>date.toTimeString();</code>  把Date对象的时间部分转换为字符串<br><code>date.toDateString();</code>  把Date对象的日期部分转换成字符串</p><h1 id="JS定时器"><a href="#JS定时器" class="headerlink" title="JS定时器"></a>JS定时器</h1><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><p>   <code>setInterval(function() {}, time);</code>time只能赋一次值，并不能通过改变time的值来动态改变隔得时间。定时器并不准。如何看时间准不准呢？写一个函数如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> lastTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"> <span class="built_in">console</span>.log(lastTime - firstTime);</span><br><span class="line"> firstTime - lastTime;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>在控制台上打印的结果并不总是1000毫秒，所以这个方法的时间间隔并不是很准的。所以要是做的功能对时间有很精确的时间要求就不能寄希望于这个方法上的。与系统执行代码所消耗的时间还有。这个方法的排列机制是基于红黑数的。每一次这个方法都会返回一个唯一标示。应用就是VIP电影有试看时间，就是用这个方法。</p><p><code>setTimeout();</code>   只执行一次。<br><code>clearInterval();</code><br><code>clearTimeout();</code><br>全局对象window上的方法，内部函数this指向window<br>注意 ：<code>setInterval(&quot;func()&quot;,1000);</code></p><h2 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a>查看滚动条的滚动距离</h2><p><code>window.pageXOffset/pageYOffset</code><br>IE8及IE8以下不兼容<br>IE8及IE8以下用的下面这个方法：<br><code>document.body/documentElement.scrollLeft/scrollTop</code><br>但是这两个方法是在IE浏览器中到底哪个能用是不一定的，又但是这两个问题是互相冲突的，一个有值另一个就没有值了。所以就让两个值加起来用。<br>兼容性比较混乱，用时取两个值相加，因为不可能存在两个同时有值</p><h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><p><strong>封装兼容性方法，求滚动轮滚动距离</strong></p><p><code>getScrollOffset()</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScrollOffset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.pageXOffset) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">x : <span class="built_in">window</span>.pageXOffset,</span><br><span class="line">y : <span class="built_in">window</span>.pageYOffset</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">x : <span class="built_in">document</span>.body.scrollLeft + <span class="built_in">document</span>.documentElement.scrollLeft,</span><br><span class="line">y : <span class="built_in">document</span>.bodu.scrollTop + <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果放大页面的尺寸。那么返回的可视区窗口就是放大之后的可视区的实际尺寸。</p><p>就在编程的html标签的上面还有一个&lt;!DOCTYPE html&gt;表示 文档类型，当有这个标签的时候浏览器的渲染模式就是标准模式，没有这个标签的时候浏览器的渲染模式就是怪异模式。渲染就是识别语法并绘制成页面。<br>标准模式：正常的渲染模式。一般除了IE浏览器其他的浏览器的与之前的变动并不是很大，所以也用不着去启用怪异模式。<br>怪异模式又叫混杂模式：试图去兼容浏览器之前的版本。</p><p><strong>有一个方法能看当前浏览器是在什么渲染模式下：</strong><br><code>document.compatMode</code>     当返回值为：”CSS1Compat”;  表示标准模式下            当返回值为：”BackCompat”  表示在怪异模式下，向后兼容</p><h2 id="查看视口的尺寸的方法："><a href="#查看视口的尺寸的方法：" class="headerlink" title="查看视口的尺寸的方法："></a>查看视口的尺寸的方法：</h2><p><code>window.innerWidth/innerHeight</code><br>IE8及IE8以下不兼容<br>标准模式下，任意浏览器都兼容的方法：<br><code>document.documentElement.clientWidth/clientHeight</code><br>适用于怪异模式下的浏览器的方法：<br><code>document.body.clientWidth/clientHeight</code></p><h2 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h2><p><strong>封装兼容性方法，返回浏览器视口尺寸</strong><br><code>getViewportOffset()</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewportOffset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.innerWidth) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">w : <span class="built_in">window</span>.innerWidth,</span><br><span class="line">h : <span class="built_in">window</span>.innerHeight</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode === <span class="string">"BackCompat"</span>)&#123;     </span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  w : <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">  h : <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">&#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode === <span class="string">"CSS1Compat"</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  w : <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">    h : <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="比较获取查看窗口尺寸的方法的取值差异："><a href="#比较获取查看窗口尺寸的方法的取值差异：" class="headerlink" title="比较获取查看窗口尺寸的方法的取值差异："></a>比较获取查看窗口尺寸的方法的取值差异：</h2><p>使用<code>$(window).width()</code>与 <code>$(window).height();</code><br>获取的是屏幕可视区域的宽高，不包括滚动条与工具条。<br><code>window.outerWidth</code> 与 <code>window.outerHeight;</code><br>获取的是加上工具条与滚动条窗口的宽高与高度(总高度算上全部滚动条的高度)。<br><code>window.innerWidth</code>与 <code>window.innerHeight;</code><br>获取的是可视区域的宽高，但是宽度包含了纵向滚动条的宽度。<br><code>document.documentElement.clientWidth</code>与 <code>document.documentElement.clientHeight;</code><br>获取的是屏幕可视区域的宽高，不包括滚动条与工具条，跟JQuery的获取的结果是一样的。<br><code>document.body.clientWidth</code> 与 <code>document.body.clientHeight;</code><br>获取的是宽度可视区域的宽度，获取的高度是是body内容的高度，如果内容只有200px，那么这个高度也是200px，如果想通过它得到屏幕可视区域的宽高，需要样式设置如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line"> <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">div</span>, <span class="selector-tag">p</span>, <span class="selector-tag">ul</span> &#123;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="兼容性："><a href="#兼容性：" class="headerlink" title="兼容性："></a>兼容性：</h2><ol><li>window.innerWidth 和 window.outerWidth 属性方法IE8以及以下不支持，得到的值为undefined。</li><li>测试浏览器IE，火狐，谷歌，Safari都支持怪异下的方法属性<code>document.documentElement.clientWidth</code> 与 <code>document.documentElement.clientHeight</code>。</li></ol><p>结论：<br>获取屏幕的可视区域的宽高可使用jQuery的方式获得，也可以使用原生js获得，即：<code>document.documentElement.clientWidth</code>与 <code>document.documentElement.clientHeight</code> 方法。</p><h2 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸"></a>查看元素的几何尺寸</h2><p><code>domEle.getBoundingClientRect();</code><br>兼容性很好，返回的是元素相对其他的最近的有定位的元素的真实的值<br>该方法返回一个对象，对象里面有left,top,right,bottom等属性。left和top代表该元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标<br>height和width代表该元素真实的自身可视高度和宽度。<br>height和width属性老版本IE并未实现<br>返回的结果并不是“实时的”，并且在Google浏览器中扩大缩小页面的内容left和right的值是会跟着变的。其他值是可视区域真实值。</p><h2 id="查看元素的尺寸"><a href="#查看元素的尺寸" class="headerlink" title="查看元素的尺寸"></a>查看元素的尺寸</h2><p><code>dom.offsetWidth，dom.offsetHeight</code></p><h2 id="查看元素的位置"><a href="#查看元素的位置" class="headerlink" title="查看元素的位置"></a>查看元素的位置</h2><p><code>dom.offsetLeft, dom.offsetTop</code><br>不管dom自身有没有定位，他都会把他跟他最近的有定位的父级元素的距离返回出来。对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。在浏览器下缩放对该方法的取值是有影响的，返回的是真实的可视区域的大小值。<br><code>dom.offsetParent</code><br>返回最近的有定位的父级，如无，返回body，<br><code>documen.body.offsetParent</code>返回null</p><h2 id="练习：-2"><a href="#练习：-2" class="headerlink" title="练习："></a>练习：</h2><p>eg：求元素相对于文档的坐标getElementPosition<br><code>function getElementPosition(dom) {  if(dom.offsetParent !== body) {    return {      x : dom.offsetLeft,        y : dom.offsetTop    }  }}</code></p><h2 id="让滚动条滚动"><a href="#让滚动条滚动" class="headerlink" title="让滚动条滚动"></a>让滚动条滚动</h2><p>window上有三个方法<br><code>scroll(),scrollTo()       scrollBy();</code><br>三个方法功能类似，用法都是将x,y坐标传入。即实现让滚动轮滚动到当前位置。前两个方法不做累加，是定点到当前所设置位置。<br>区别：scrollBy()会在之前的数据基础之上做累加。</p><p>eg：利用scrollBy() 快速阅读的功能    加锁式的编程方法<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="built_in">style</span>='<span class="built_in">width</span>:100px;<span class="built_in">height</span>:100px;<span class="built_in">background</span>-<span class="built_in">color</span>:orange;<span class="built_in">color</span>:#fff;<span class="built_in">font</span>-size:40px;<span class="built_in">font</span>-weight:bold;text-align:<span class="built_in">center</span>;line-<span class="built_in">height</span>:100px;<span class="built_in">position</span>:fixed;bottom:200px;right:50px;<span class="built_in">border</span>-<span class="built_in">radius</span>:<span class="number">50</span><span class="symbol">%</span>;<span class="built_in">opacity</span>:<span class="number">0.5</span>;'&gt; start &lt;/div&gt;</span><br><span class="line">&lt;div <span class="built_in">style</span>='<span class="built_in">width</span>:100px;<span class="built_in">height</span>:100px;<span class="built_in">background</span>-<span class="built_in">color</span>:red;<span class="built_in">color</span>:#fff;<span class="built_in">font</span>-size:40px;<span class="built_in">font</span>-weight:bold;text-align:<span class="built_in">center</span>;line-<span class="built_in">height</span>:100px;<span class="built_in">position</span>:fixed;bottom:400px;right:50px;<span class="built_in">border</span>-<span class="built_in">radius</span>:<span class="number">50</span><span class="symbol">%</span>;<span class="built_in">opacity</span>:<span class="number">0.5</span>;'&gt; stop &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">var</span> start = document.getElementsByTagName('div')[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">var</span> stop = document.getElementsByTagName('div')[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">key</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">timer</span> = <span class="number">0</span>;</span><br><span class="line">    start.onclick = function () &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">key</span>) &#123;</span><br><span class="line">          <span class="built_in">timer</span> = setInterval(function () &#123;</span><br><span class="line">      window.scrollBy(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">          &#125;, <span class="number">100</span>);</span><br><span class="line">          <span class="built_in">key</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stop.onclick = function () &#123;</span><br><span class="line">      clearInterval(<span class="built_in">timer</span>);</span><br><span class="line">      <span class="built_in">key</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="间接控制脚本化CSS属性的方法："><a href="#间接控制脚本化CSS属性的方法：" class="headerlink" title="间接控制脚本化CSS属性的方法："></a>间接控制脚本化CSS属性的方法：</h2><p>读写元素css属性<br><code>dom.style.prop</code><br>可读写行间样式，只能读写行间的值，写到别的地方是读写不出来的。写入操作的唯一方法，其他的方法只能读不能写入了。<br>没有兼容性问题，碰到float这样的关键字属性，前面应加css<br>eg:float — &gt; cssFloat<br>复合属性必须拆解，组合单词变成小驼峰式写法<br>写入的值必须是字符串格式</p><h2 id="查询计算样式"><a href="#查询计算样式" class="headerlink" title="查询计算样式"></a>查询计算样式</h2><p>这个方法传入的第二个参数null传入的是什么呢？传入的是获取伪元素，原生的方法。获取伪元素的属性，伪元素的display默认是inline-block；例如获取一个DOM元素div的伪元素的样式表。就是<code>window.getComputedStyle(div, &quot;after&quot;)[&#39;prop&#39;]</code>就是获取的这个div上的伪元素属性after的一些值，但是不能操作，只能取出来。如何改变伪元素的需求呢？当点击一个DOM元素div的时候，让div上的一个伪元素变化。也就是操作CSS的样式上加上一些东西。改变原先的class名字而且先写好CSS样式。</p><p><code>window.getComputedStyle(ele,null);</code>显示获取出来的是显示展示能看见的真实值，获取出来的是一个对象，还可以.属性，获取出具体的一个属性值。<br>计算样式只读<br>返回的计算样式的值都是绝对值，没有相对单位（em）<br>IE8 及 IE8以下不兼容</p><p>查看IE8及IE8以下的属性的特有的方法<br>查询样式<br><code>ele.currentStyle</code><br>计算样式只读<br>返回的计算样式的值不是经过转换的绝对值<br>IE独有的属性</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>封装兼容性方法getStyle(obj,prop);</strong>  这个方法获取的很靠谱。并且这个方法获取的值是字符串形式的eg“8px”；所以用的时候需要用parseInt()方法来把后面的字符串截断成纯数字形式的，这样我们才能使用。</p><p><code>function getStyle(elem, prop) {  if(window.getComputedStyle) {    return window.getComputedStyle(elem, null)[prop];  }else{    return elem.currentStyle[prop];  }}</code></p><h1 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h1><p>JSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的）   最开始的时候前后端交流的是使用xml的形式的，但是现在用的是JSON的形式；<br>可以把JSON当成一个构造函数，它里面就有如下两个方法：<br>JSON.parse();   string—&gt;json<br>JSON.stringify();   json—-&gt;string<br>是因为我们传输的信息就是字符串形式的：可以互相转换。</p><h2 id="静态类："><a href="#静态类：" class="headerlink" title="静态类："></a>静态类：</h2><p>js是面向过程正在朝面向对象过渡的过程：例如：<br>setInterval() 这个方法是window上的，js上定义的一些方法<br>Math()这个方法，5年前是定义在function Math() {}上的；现在是一个对象。一些方法直接定义在了Math() 身上，所以想用的时候就不用new了，各有各的好处。他们身上的方法就叫做静态方法，静态类的总称。Math.floor()向下取整；Math.ceil()向上取整；Math.abs()取绝对值(absolute);Math.random()  0-1之间的任意小数；Math.sqrt()开方；</p><h2 id="时间线："><a href="#时间线：" class="headerlink" title="时间线："></a>时间线：</h2><p>js加载的缺点：加载工具方法没必要阻塞文档，使得js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。<br>有些工具方法需要按需加载，用到再加载，不用不加载。</p><h2 id="javascript-异步加载-的-三种方案"><a href="#javascript-异步加载-的-三种方案" class="headerlink" title="javascript 异步加载 的 三种方案"></a>javascript 异步加载 的 三种方案</h2><ol><li><p>defer 异步加载，下载完不是立刻执行，是要等到dom文档全部解析完才会被执行。只有IE能用。IE10以下的可用。不光是页面内的js文件还是页面外引入的都会变成异步加载的。<br><script type="text/javascript" defer="defer" src="xxx.js"></script>可以简化成defer<br>就比如说页面中有一个img标签，先解析，加到DOM树上；再加载，比如图片需要加载图片的二进制文档，也就是下载，下载完了也就是加载完了；最后绘制渲染出来。</p></li><li><p>async 异步加载，加载完就执行，async只能加载外部脚本，不能把js写在script 标签里。这个方法只能是加载外部js引用时才能异步加载。<br><script type="text/javascript" async="async" src="xxx.js"></script><br>asynchronous javascript and xml —–&gt;  Ajax</p></li></ol><p>1和2 执行时也不阻塞页面，但是不能两个同时用。一般公司都会采用牺牲IE的方法只用async的。</p><ol start="3"><li>创建script，插入到DOM中，加载完毕后callBack</li></ol><h2 id="按需加载异步下载js的兼容性写法："><a href="#按需加载异步下载js的兼容性写法：" class="headerlink" title="按需加载异步下载js的兼容性写法："></a>按需加载异步下载js的兼容性写法：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.type = <span class="string">"text/jacascript"</span>;</span><br><span class="line">  script.src = url;</span><br><span class="line">  <span class="keyword">if</span>(script.readyState) &#123;</span><br><span class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(script.readyState == <span class="string">"complete"</span> ||  script.readyState == <span class="string">"loaded"</span>) &#123;</span><br><span class="line">  callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    script.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">'tools.js'</span>, getScrollOffset);</span><br></pre></td></tr></table></figure><p>这里有一个问题，就是还没等到工具js包下载完呢，就调用这个包里面的方法肯定会报错的。解决方法为可以<code>loadScript(&#39;tools.js&#39;, function() {console.log(getScrollOffset())});</code>或者把tools.js里面的方法都整合到一个对象里面：在js包里： <code>var obj={getScrollOffset: function() {console.log(&#39;a&#39;)}};</code>然后再把上面这个方法也改了，改成  <code>obj[callback]();</code>这样就可以这样用了<code>loadScript(&#39;tools.js&#39;, &#39;getScrollOffset&#39;);</code></p><h2 id="js时间线："><a href="#js时间线：" class="headerlink" title="js时间线："></a>js时间线：</h2><ol><li>创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。</li><li>遇到link外部css，创建线程加载，并继续解析文档。</li><li>遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</li><li>遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。<br>对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()因为该方法会清空之前写的所有文档流）</li><li>遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</li><li>当文档解析完成，document.readyState = ‘interactive’。</li><li>文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）;</li><li>当文档解析完成后，document对象触发DOMContentLoaded事件，一触发就标志着解析完毕了。这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</li><li>当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，也就是当所有的东西都加载完成之后，window对象触发load事件。加载完成就开始渲染，所有的东西都就画出来了，用户可以看见东西了。</li><li>从此，以异步响应方式处理用户输入、网络事件等。</li></ol><p><strong>绑定事件的时候，无论多少的单词都不会大写的，但是只有一个特殊的就是’DOMContentLoaded’。</strong><br><code>document.readyState 三个阶段：loading、interactive、comolete.</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><p>这样打印出来就是： ‘interactive’<br>再复习一下第三个参数false是什么意思呢，就是捕获，绑定事件监听的事件处理模型只能有两种行为，一个是捕获，另一个是冒泡。true的时候就是冒泡。</p><h2 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h2><p><strong>请编写一段JavaScript脚本生成下面这段DOM结构。要求：使用标准的DOM方法或属性。</strong><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"example"</span>&gt;</span><br><span class="line">&lt;p <span class="built_in">class</span>=<span class="string">"slogan"</span>&gt;姬成，你最帅!&lt;/p&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><p>提示 dom.className 可以读写class<br><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">div</span> = document.createElement(<span class="string">'div'</span>),</span><br><span class="line">    p = document.createElement(<span class="string">'p'</span>);</span><br><span class="line">p.innerText = <span class="string">'姬成，你最帅！'</span>;      也可以  <span class="keyword">var</span> text = document.createTextNode(<span class="string">'姬成，你最帅！'</span>);</span><br><span class="line"><span class="keyword">div</span>.appendChild(p);</span><br><span class="line">document.body.appendChild(<span class="keyword">div</span>);</span><br><span class="line"><span class="keyword">div</span>.setAttribute(<span class="string">'class'</span>, <span class="string">'example'</span>);</span><br><span class="line">p.setAttribute(<span class="string">'class'</span>, <span class="string">'slogan'</span>);</span><br><span class="line">有一个注意的点就时appendChild()括号里没有<span class="string">''</span>!!! 应该直接在里面写原生DOM   appendChild(<span class="keyword">div</span>)</span><br></pre></td></tr></table></figure></p><ol><li><p>封装函数insertAfter()；功能类似insertBefore();<br>提示:可忽略老版本浏览器，直接在Element.prototype上编程</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.insertAfter = <span class="function"><span class="keyword">function</span> <span class="params">(targetNode, afterNode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> beforeNode = afterNode.nextElementSibling;</span><br><span class="line">  <span class="keyword">if</span>(beforeNode) &#123;</span><br><span class="line">    <span class="keyword">this</span>.insertBefore(targetNode, beforeNode);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.appendChild(targetNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将目标节点内部的节点顺序逆序。<br>eg:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"> </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">Element.prototype<span class="built_in">.reverse</span> = <span class="keyword">function</span> (dom) &#123;</span><br><span class="line">  var len = this.length;</span><br><span class="line">  <span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    this.</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="作业区："><a href="#作业区：" class="headerlink" title="作业区："></a>作业区：</h1><ol><li><p>遍历元素节点树，要求不能用children属性</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">var div =<span class="built_in"> document</span>.getElementByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">function</span> retElementChild(<span class="type">node</span>) &#123;</span><br><span class="line">  var temp = &#123;</span><br><span class="line">     length : <span class="number">0</span>,</span><br><span class="line">     push : Array.prototype.push,</span><br><span class="line">     splice : Array.prototype.splice</span><br><span class="line">  &#125;,</span><br><span class="line">      child = <span class="type">node</span>.childNodes,</span><br><span class="line">      len = child.length;</span><br><span class="line">  <span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">     <span class="keyword">if</span>(child[i].nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">temp.push(child[i]);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retElement(div)</span><br></pre></td></tr></table></figure></li><li><p>封装函数，返回元素e的第n层祖先元素</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> retParent(elem, n) &#123;</span><br><span class="line">  while(n &amp;&amp; elem) &#123;</span><br><span class="line">    elem = elem.parentElement;</span><br><span class="line">    n --;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0，返回自己。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;span&gt;</span><br><span class="line">     &lt;p&gt;</span><br><span class="line">&lt;strong&gt;</span><br><span class="line">  &lt;em&gt;&lt;/em&gt;</span><br><span class="line">&lt;/strong&gt;</span><br><span class="line">     &lt;/p&gt;</span><br><span class="line">   &lt;/span&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">function retSibing(<span class="built_in">e</span>, n) &#123;</span><br><span class="line">  <span class="keyword">while</span>(n &amp;&amp; <span class="built_in">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">e</span>.nextElementSibling) &#123;</span><br><span class="line">          <span class="built_in">e</span> = <span class="built_in">e</span>.nextElementSibling;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(var <span class="built_in">e</span> = <span class="built_in">e</span>.nextSibling; <span class="built_in">e</span> &amp;&amp; <span class="built_in">e</span>.nodeType != <span class="number">1</span>; <span class="built_in">e</span> = <span class="built_in">e</span>.nextSibling);</span><br><span class="line">&#125;</span><br><span class="line">n --;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">e</span>.previousElementSibling) &#123;</span><br><span class="line">  <span class="built_in">e</span> = <span class="built_in">e</span>.previousElementSibling;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(var <span class="built_in">e</span> = <span class="built_in">e</span>.previousSibling; <span class="built_in">e</span> &amp;&amp; <span class="built_in">e</span>.nodeType != <span class="number">1</span>; <span class="built_in">e</span> = <span class="built_in">e</span>.previousSibling);</span><br><span class="line">&#125;</span><br><span class="line">n ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">e</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑函数，封装children功能，解决以前部分浏览器的兼容性问题,就是用自己的方法实现children方法。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">var div =<span class="built_in"> document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">Element.prototype.myChildren = <span class="keyword">function</span> () &#123;</span><br><span class="line"> var child = this.childNodes,</span><br><span class="line">     len = child.length,</span><br><span class="line">     arr = [];</span><br><span class="line"> <span class="keyword">for</span>(var i = <span class="number">0</span>；i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(child[i].nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">arr.push(child[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">div.myChildren();    结果为：[span]</span><br></pre></td></tr></table></figure></li><li><p>自己封装hasChildren()方法，不可用children属性。如果有元素节点返回true，如果没有返回false。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">   </span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">     </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">var div =<span class="built_in"> document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">Element.prototype.hasChildren = <span class="keyword">function</span> () &#123;</span><br><span class="line">  var child = this.childNodes,</span><br><span class="line">      len = child.length,</span><br><span class="line">      arr = [];</span><br><span class="line">  <span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">     <span class="keyword">if</span>(child[i].nodeType == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span><span class="built_in"> true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span><span class="built_in"> false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.hasChildren();   结果<span class="built_in">：true</span>;</span><br></pre></td></tr></table></figure></li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 浏览器之DOM：&lt;/strong&gt; &lt;excerpt in index | 首页摘要&gt;&lt;/excerpt&gt;&lt;/p&gt;
&lt;p&gt;DOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://dexinser.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS小技巧</title>
    <link href="https://dexinser.github.io/2017/12/CSS%E6%8A%80%E5%B7%A7.html"/>
    <id>https://dexinser.github.io/2017/12/CSS技巧.html</id>
    <published>2017-12-09T16:00:00.000Z</published>
    <updated>2022-11-14T16:34:46.578Z</updated>
    
    <content type="html"><![CDATA[<p><strong> CSS小技巧：</strong> <Excerpt in index | 首页摘要></p><p>清除浮动元素的技巧解析~<br><a id="more"></a></p><The rest of contents | 余下全文><p>清除浮动元素的技巧解析:<br>display:block;<br>height:0;<br>line-height:0;<br>content:’ ‘;<br>clear:both;<br>visibility:hidden;<br>这些是设置在元素的伪元素上的，比如要是想在当前元素的后面设置清除浮动，那就设置元素的:after设置上面的属性；要是想在当前元素的前面清除浮动，那就设置当前元素的:before上设置前面的属性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; CSS小技巧：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;清除浮动元素的技巧解析~&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="https://dexinser.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>使用CSS3开启GPU硬件加速提升网站动画渲染性能</title>
    <link href="https://dexinser.github.io/2017/12/CSS3%E4%B8%ADtransform%E7%9A%84%E5%8A%A0%E9%80%9F%E9%97%AE%E9%A2%98.html"/>
    <id>https://dexinser.github.io/2017/12/CSS3中transform的加速问题.html</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2022-11-14T16:34:28.658Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 使用CSS3开启GPU硬件加速提升网站动画渲染性能：</strong> <Excerpt in index | 首页摘要></p><p>今天再来说一下CSS3中的新特性，transform。说他之前先来解释图片中的两个格式的区别：PNG8和PNG24。<br><a id="more"></a></p><The rest of contents | 余下全文><p>今天再来说一下CSS3中的新特性，transform。说他之前先来解释图片中的两个格式的区别：PNG8和PNG24。</p><h1 id="png8"><a href="#png8" class="headerlink" title="png8"></a>png8</h1><p>每一张“png8”图像，都最多只能展示256种颜色，所以“png8”格式更适合那些颜色比较单一的图像，例如纯色、logo、图标等；因为颜色数量少，所以图片的体积也会更小；</p><h1 id="png-24"><a href="#png-24" class="headerlink" title="png 24"></a>png 24</h1><p>每一张“png24”图像，可展示的颜色就远远多于“png8”了，最多可展示的颜色数量可多达1600万；所以“png24”所展示的图片颜色会更丰富，图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以“png24”的图片比较适合像摄影作品之类颜色比较丰富的图片；</p><p>所以一些网站如果需要加载一些很大的PNG24类型的图片的话，那么图片加载的时间就会有点长甚至导致网站出现卡顿现象，进而影响用户体验。我们如何解决这个问题呢？或者说如何优化这个麻烦呢？这就需要我们今天要说到的CSS3中的transform属性了。为什么添加这个属性之后就会提升性能呢？因为为动画DOM元素添加CSS3样式-webkit-transform:transition3d(0,0,0)或-webkit-transform:translateZ(0);，这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画时从CPU转向GPU，其实说白了这是一个小伎俩，也可以算是一个Hack，-webkit-transform:transition3d和-webkit-transform:translateZ其实是为了渲染3D样式，但我们设置值为0后，并没有真正使用3D效果，但浏览器却因此开启了GPU硬件加速模式。<br>　　这种GPU硬件加速在当今PC机及移动设备上都已普及，在移动端的性能提升是相当显著地，所以建议大家在做动画时可以尝试一下开启GPU硬件加速。</p><p>当然也可以这样开启所有浏览器的GPU硬件加速：</p><blockquote><p>-webkit-transform: translateZ(0);<br>-moz-transform: translateZ(0);<br>-ms-transform: translateZ(0);<br>-o-transform: translateZ(0);<br>transform: translateZ(0);</p></blockquote><p>或者：</p><blockquote><p>-webkit-transform: translate3d(0,0,0);<br>-moz-transform: translate3d(0,0,0);<br>-ms-transform: translate3d(0,0,0);<br>-o-transform: translate3d(0,0,0);<br>transform: translate3d(0,0,0);</p></blockquote><p>但是我们要注意的是：开启GUI加速之后，会出现一些意想不到的BUG问题。当你有多个position:absolute;元素添加-webkit-transform:transition3d(0,0,0);开启GPU硬件加速之后，会有几个元素凭空消失，调试许久无果遂Google之，国内暂时没有人发表过关于这类问题的文章，于是在国外网站找呀找，找到了很多与我遇到同样问题的人，但都没有真正靠谱的解决办法，这可能是跟添加-webkit-transform之后chrome尝试使用GPU硬件加速有关系。<br>在使用-webkit-transform尝试对很多DOM元素编写3D动画时，尽量不要对这些元素及他们的父元素使用position:absolute/fixed。(其实这种情况很难避免)</p><p>通过-webkit-transform:transition3d/translateZ开启GPU硬件加速之后，有些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决之：</p><blockquote><p>-webkit-backface-visibility:hidden;<br>-webkit-perspective:1000;</p></blockquote><p>通过-webkit-transform:transition3d/translateZ开启GPU硬件加速的适用范围：</p><ol><li>使用很多大尺寸图片(尤其是PNG24图)进行动画的页面。</li><li>页面有很多大尺寸图片并且进行了css缩放处理，页面可以滚动时。</li><li>使用background-size:cover设置大尺寸背景图，并且页面可以滚动时。(详见: <a href="https://coderwall.com/p/j5udlw">https://coderwall.com/p/j5udlw</a> )</li><li>编写大量DOM元素进行CSS3动画时(transition/transform/keyframes/absTop&amp;Left)</li><li>使用很多PNG图片拼接成CSS Sprite时</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 使用CSS3开启GPU硬件加速提升网站动画渲染性能：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;今天再来说一下CSS3中的新特性，transform。说他之前先来解释图片中的两个格式的区别：PNG8和PNG24。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://dexinser.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS3" scheme="https://dexinser.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS3选择器的使用方法</title>
    <link href="https://dexinser.github.io/2017/12/CSS3-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>https://dexinser.github.io/2017/12/CSS3-选择器的使用.html</id>
    <published>2017-12-07T16:00:00.000Z</published>
    <updated>2022-11-14T16:34:11.734Z</updated>
    
    <content type="html"><![CDATA[<p><strong> CSS3选择器的使用方法：</strong> <Excerpt in index | 首页摘要></p><p>学习css必须要精通的基础哦~CSS3—选择器详解， 属性选择器 一起来看看吧~<br><a id="more"></a></p><The rest of contents | 余下全文><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>增加了可以使用正则匹配属性名的方法：<br>E[att^=“val”] {…}  选择匹配元素E, 且E元素定义了属性att, 其属性值以val开头的任何字符串<br>E[att$=“val”]{…}选择匹配元素E, 且E元素定义了属性att, 其属性值以val结尾的任何字符串<br>E[att*=“val”]{…}选择匹配元素E, 且E元素定义了属性att, 其属性值任意位置出现了“val”。即属性值包含了“val”，位置不限。</p><h2 id="初级伪类选择器：伪类用于向某些选择器添加特殊的效果。"><a href="#初级伪类选择器：伪类用于向某些选择器添加特殊的效果。" class="headerlink" title="初级伪类选择器：伪类用于向某些选择器添加特殊的效果。"></a>初级伪类选择器：伪类用于向某些选择器添加特殊的效果。</h2><h3 id="1-root-根标签选择器"><a href="#1-root-根标签选择器" class="headerlink" title="1.root 根标签选择器"></a>1.root 根标签选择器</h3><p>“:root”选择器等同于<html>元素，简单点说：<br>:root{background:orange}<br>html{background:orange}<br>得到的效果等同<br>建议使用:root（xml等）</p><h3 id="2-not-否定选择器"><a href="#2-not-否定选择器" class="headerlink" title="2.not 否定选择器"></a>2.not 否定选择器</h3><p>用法和jQuery 中的not类似，可以排除某些特定条件的元素<br>div:not([class=“demo”]){<br>background-color:red;<br>}<br>意思为除了class为demo的div以外，所有的div的背景颜色都变红</p><h3 id="3-empty-空标签选择器"><a href="#3-empty-空标签选择器" class="headerlink" title="3.empty 空标签选择器"></a>3.empty 空标签选择器</h3><p>用来选择没有内容的元素、不在文档树中的元素，这里的没有内容指的是一点内容都没有，哪怕是一个空格。</p><h3 id="4-target-目标元素选择器"><a href="#4-target-目标元素选择器" class="headerlink" title="4.target 目标元素选择器"></a>4.target 目标元素选择器</h3><p>用来匹配被location.hash 选中的元素(即锚点元素)<br>选择器可用于选取当前活动的目标元素，被设置为锚点的元素被锚点之后就可以显示相应的css样式。</p><h3 id="5-first-child-第一个子元素"><a href="#5-first-child-第一个子元素" class="headerlink" title="5.:first-child 第一个子元素"></a>5.:first-child 第一个子元素</h3><p>:last-child 最后一个子元素<br>:nth-child(){} 第xxx个子元素，n代表变量自然数<br>:nth-last-child(){}  从后往前数<br>以上四个选择器均有弊端，即如果当前位置元素不是前面所修饰的元素，那么无效<br>注：其父元素的第 N 个子元素，不论元素的类型。</p><h3 id="6-first-of-type-第一个子元素"><a href="#6-first-of-type-第一个子元素" class="headerlink" title="6.:first-of-type 第一个子元素"></a>6.:first-of-type 第一个子元素</h3><p>:last-of-type 最后一个子元素<br>:nth-of-type(){} 第xxx个子元素，n代表变量自然数<br>:nth-last-of-type(){}  从后往前数<br>此种选择器，限制了类型，即在所修饰元素的类型下选择特定位置的元素。</p><h3 id="7-only-child-唯一子元素选择器"><a href="#7-only-child-唯一子元素选择器" class="headerlink" title="7 :only-child  唯一子元素选择器"></a>7 :only-child  唯一子元素选择器</h3><p>选择是独生子的子元素，即该子元素不能有兄弟元素，它的父元素只有他一个直接子元素。<br>注意：选择的元素是独生子子元素，而非有唯一子元素的父元素。<br>:only-of-type<br>如果要选择第某类特定的子元素(p) 在兄弟节点中是此类元素唯一个的话 就需要用到这个属性了</p><h3 id="8-enabled-可用的元素-disabled-不可用的元素"><a href="#8-enabled-可用的元素-disabled-不可用的元素" class="headerlink" title="8 :enabled  可用的元素   :disabled 不可用的元素"></a>8 :enabled  可用的元素   :disabled 不可用的元素</h3><p>在web的表单中，有些表单元素有可用（“enabled”）和不可用（“disabled”）状态，比如输入框，密码框，复选框等。在默认情况下，这些表单元素都处在可用状态。那么我们可以通过伪类选择器 enabled 进行选择，disabled则相反。</p><h3 id="9-checked-选择框的被选中状态"><a href="#9-checked-选择框的被选中状态" class="headerlink" title="9:checked  选择框的被选中状态"></a>9:checked  选择框的被选中状态</h3><p>注：checkbox, radio 的一些默认状态不可用属性进行改变，如宽高颜色。</p><h3 id="10-read-only-选中只读的元素"><a href="#10-read-only-选中只读的元素" class="headerlink" title="10:read-only  选中只读的元素"></a>10:read-only  选中只读的元素</h3><p>eg:<code>&lt;input type=“text” readonly=“readonly”/&gt;</code><br>:read-write 选中非只读的元素<br>eg:<code>&lt;input type=“text”/&gt;</code></p><h5 id="扩张内容：伪类与伪元素的区别"><a href="#扩张内容：伪类与伪元素的区别" class="headerlink" title="扩张内容：伪类与伪元素的区别"></a>扩张内容：伪类与伪元素的区别</h5><blockquote><p>伪类的效果可以通过添加一个实际的类来达到。<br>伪元素的效果则需要通过添加一个实际的元素才能达到。<br>这也是为什么他们一个称为伪类，一个称为伪元素的原因。</p></blockquote><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p>CSS3对伪元素进行了一定的调整，在以前的基础上增加了一个:也就是现在变成了::first-letter,::first-line,::before,::after<br>另外还增加了一个::selection</p><h3 id="1-selection"><a href="#1-selection" class="headerlink" title="1.::selection"></a>1.::selection</h3><p>“::selection” 选择器是用来匹配突出显示的文本（用鼠标选择文本的时候）。浏览器默认情况下，用鼠标选择网页文本是以“蓝色的北京，白色的字体”显示的。<br>属性：user-select: none;<br>注：火狐下必须加-moz-<br>-moz-::selection</p><h2 id="条件选择"><a href="#条件选择" class="headerlink" title="条件选择"></a>条件选择</h2><p>E &gt; F  an F element child of an E element<br>直接子元素<br>E + F an F element immediately preceded by an E element<br>后面的紧挨着的兄弟节点<br>E ~ F an F element preceded by an E element<br>后面的兄弟节点</p><pre><code>Author:By--Dexinser</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; CSS3选择器的使用方法：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;学习css必须要精通的基础哦~CSS3—选择器详解， 属性选择器 一起来看看吧~&lt;br&gt;
    
    </summary>
    
      <category term="必备知识" scheme="https://dexinser.github.io/categories/%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="CSS3" scheme="https://dexinser.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Amour-影评</title>
    <link href="https://dexinser.github.io/2017/12/2017.12.08%20Amour.html"/>
    <id>https://dexinser.github.io/2017/12/2017.12.08 Amour.html</id>
    <published>2017-12-07T16:00:00.000Z</published>
    <updated>2022-11-14T16:30:26.828Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Amour-影评</strong>   <Excerpt in index | 首页摘要></p><p>我今年23岁，在我的这有限的人生阅历中，只经历过一次亲人的离世–我的姥爷。昨天看完了法国2012年上映的电影《Amour》，让我有很大的感触，也让我回想起了我的姥爷。<br><a id="more"></a></p><The rest of contents | 余下全文><p>我今年23岁，在我的这有限的人生阅历中，只经历过一次亲人的离世–我的姥爷。昨天看完了法国2012年上映的电影《Amour》，让我有很大的感触，也让我回想起了我的姥爷。人生生老病死本是常态，但是当一个人慢慢变老，而由变老带来的一系列问题真的是很让人无奈又不甘心的吧！与天斗，与地斗，与人斗，最后变成了与自己斗！<br>影片中的两位主人公都是已经退休的80多岁的音乐老师，本来在安享晚年的时候，却横遭变故，女主角Anne毫无征兆的突然中风，而后右半身偏瘫，直至最后的卧床不起..而后是男主角Georges照顾Anne的一系列平常的事情，但是也正是在平常的生活中才能见证两个人的感情..以及各自的心理变化，到最后男主的妥协..<br>这部电影讲的太过于真实，以至于直敲心灵深处。看完这部电影就像影片中男主角说他小时候看过的电影一样，看的过程中很触动感情，看完之后再回想的时候更是一发不可收拾。昨天晚上看完这部电影，今天早上再回想起来的时候眼泪更是止不住的留下来，真的跟男主角说的一样..难道这也是导演做的对这部电影的铺垫吗？<br>这部电影从头到尾都是平铺直叙式的拍摄方式，背景音乐也只是再特定的时候才用到了钢琴曲，我不敢去看第二遍了，所以这是我大概的记忆，不知道对不对。没有生活中的大起大落，只是平常生活中的平平淡淡的像极了平常人的老年生活，但是也正是这样，才直指人内心深处的感触，才能激起泪腺啊！才让我对爱有了更为真实的定义。</p><h1 id="女主角的心理历程"><a href="#女主角的心理历程" class="headerlink" title="女主角的心理历程"></a>女主角的心理历程</h1><p>从一开始的病情征兆的出现，女主角对自己的病情很害怕，因为是80对岁的人了，做手术风险很高，对一般人来说几乎没什么风险的手术，都年纪很大的女主角来说风险很高了。影片中男主角也说到了做手术的风险很低，但是不巧的是女主角正好是那风险很低的5%的一部分里。做完手术后身体半瘫，从刚开始的难以接受，自尊心受到了极大的打击，乃至于男主角有一天去参加一个朋友的葬礼，提前回来之后发现女主角倒在开着的窗台下面，男主角没有问为什么会发生这样的事，他应该也能猜到Anne的想法，觉得自己是一个累赘，不如一死了之。再到Anne看相册时说的一句话：人生真是太过漫长了。听到这儿，Georges不知该说什么，明白了Anne的心思。</p><p>片中的一幕死亡引起了不少观众的非议，这不禁让我想起“安乐死”的议题。笔者所在的荷兰是最早通过“安乐死”的国家，“安乐死”其实是对生者权利和意愿的尊重。电影中的这一幕，有区别，却也有类同。许多观众无法对片中展示的价值观进行认同，其实我看《Amour》的时候，当乔治拿起枕头时，也先是吃惊，不解，随后心中却升起无尽的悲凉。电影中的细节已经无数次提醒观众：Anne去意已决，当George回家看到Anne跌坐在窗口，Anne已有了跳楼离世之心；当Anne翻起相册时，她不是已经说过，人生之于她，已经太过于漫长了么？当她彻夜喊着“痛”，喊着“妈妈”时，她难道不是已经无法再忍受下去了么？当George给Anne喂汤时，她莫非不也是无法接受最后的怜悯了么？巴掌打在Anne的脸上，却也重重打在了George的心上，这样下去的苟延残喘，只会带来互相伤害，保姆已经用梳头和镜子彻底摧毁了Anne仅剩的一点点自尊心，他又能带给她什么呢？</p><p>于是我泪流满面，明白了George的用意，与其让爱人痛苦着死去，不如让她快乐地活在他心里。一辈子的相濡以沫，又怎么会不懂得爱人的心意呢？那些只看到“谋杀”的观众，恐怕涉世未深，对“爱”无法理解吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Amour-影评&lt;/strong&gt;   &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;我今年23岁，在我的这有限的人生阅历中，只经历过一次亲人的离世–我的姥爷。昨天看完了法国2012年上映的电影《Amour》，让我有很大的感触，也让我回想起了我的姥爷。&lt;br&gt;
    
    </summary>
    
      <category term="个人分享" scheme="https://dexinser.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="影评" scheme="https://dexinser.github.io/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新增加的功能和属性方法--之选择器</title>
    <link href="https://dexinser.github.io/2017/12/CSS3-%E7%AE%80%E4%BB%8B.html"/>
    <id>https://dexinser.github.io/2017/12/CSS3-简介.html</id>
    <published>2017-12-06T16:00:00.000Z</published>
    <updated>2022-11-14T16:33:46.096Z</updated>
    
    <content type="html"><![CDATA[<p><strong> CSS3新增加的功能和属性方法--之选择器：</strong> <Excerpt in index | 首页摘要></p><p>学习css必须要精通的基础哦~CSS3—选择器详解，一起来看看吧~<br><a id="more"></a></p><The rest of contents | 余下全文><h1 id="CSS3—选择器"><a href="#CSS3—选择器" class="headerlink" title="CSS3—选择器"></a>CSS3—选择器</h1><p>提供了更加强大且精准的选择器，提供多种背景填充方案，可以实现渐变颜色，可以改变元素的形状、角度等，可以加阴影效果，报纸布局，弹性盒子，ie6混杂模式的盒模型，新的计量单位，动画效果等等等…</p><p>  在CSS3的一些新特性或方法还没正式使用之前，有一些浏览器商为了竞争用户使用人数或者说是为了一些商业目的，在CSS3还没有正式通过使用时就在自家的浏览器上实现了CSS3新出的功能。而这些浏览器商为了显示出这是自家的浏览器上实现的CSS3新功能，所以他们就在新实现的CSS3功能的属性之前加上了自家的标志。添加的前缀标志如下：<br>  在编写CSS3样式时，不同的浏览器可能需要不同的前缀。它表示该CSS属性或规则尚未成为W3C标准的一部分，是浏览器的私有属性，虽然目前较新版本的浏览器都是不需要前缀的，但为了更好的向前兼容前缀还是少不了的。</p><h3 id="以CSS3新属性border-radius为例："><a href="#以CSS3新属性border-radius为例：" class="headerlink" title="以CSS3新属性border-radius为例："></a>以CSS3新属性border-radius为例：</h3><blockquote><p>-webkit-border-radius<br>Chrome和Safari</p><p>-moz-border-radius<br>Firefox</p><p>-ms-border-radius<br>IE</p><p>-o-border-radius<br>Opera</p></blockquote><p>CSS3新添加的属性方法有哪些?</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>添加圆角 – border-radius 这是一个复合属性，分别为代表左上角、右上角、右下角、左下角；而且他们的所代表的左上角还是一个小的复合属性，又可以分成x轴和y轴的偏移量。 还有一种写法border-radius： 1em 2em 3em 4em / 2em 3em 4em 5em;</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>添加盒子阴影 –  box-shadow  这也是一个复合属性，是添加盒子阴影的方法。<br>box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];  []里面的属性代表可以省略的属性。需要注意的是最后的一个可选属性即投影方式默认是outset投影方式，如果想设置成默认向外投影方式的话，一定注意不要把这个属性值写上去，写上去的话就不好使了，就没有阴影了，但是如果想改变投影方式为其他的形式需要写上去的。同一盒子，可以同时加多个阴影，阴影之间用“,”隔开。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>添加文本阴影  text-shadow<br>语法<br>text-shadow:X-Offset Y-Offset blur color;<br>X-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移；<br>Y-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移<br>Blur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0；<br>Color：是指阴影的颜色，其可以使用rgba色。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>颜色值RGBA  再原先RGB的基础上添加了透明度这一参数。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>CSS3的渐变分为两种<br>1）线性渐变（linear - to）<br>语法: linear-gradient([direction], color [percent], color [percent], …)<br>[] 内为选填<br>direction角度的单位为 “deg” 也可以用to bottom, to left, to top left等的方式来表达<br>2）径向渐变（radial - at）<br>语法:radial-gradient(shape at position, color [percent] , color, …)<br>shape:放射的形状，可以为原型circle，可以为椭圆ellipse<br>position: 圆心位置，可以两个值，也可以一个，如果为一个时，第二个值默认center 即 50%。值类型可以为，百分数，距离像素，也可以是方位值(left,top…); /<em>x 轴主半径 y轴次半径</em>/</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>文字边界换行<br>word-wrap:normal|break-word;</p><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>可以下载网上的好看的字体想要引入的话就用下面的方式把下载到包用到我们的网页上，字体的包有很多格式，有的浏览器不支持某一种格式的话就换一种：<br><code>font-face@font-face{font-family:”myFirstFont”;src:url(&#39;Sansation_Light.ttf&#39;),url(‘Sansation_Light.eot&#39;) format(‘eot’)；下载前面的优先选用}@font-face {    font-family: &#39;diyfont&#39;;    src: url(&#39;diyfont.eot&#39;); /* IE9+ */    src: url(&#39;diyfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */         url(&#39;diyfont.woff&#39;) format(&#39;woff&#39;), /* chrome、firefox */         url(&#39;diyfont.ttf&#39;) format(&#39;truetype&#39;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/         url(&#39;diyfont.svg#fontname&#39;) format(&#39;svg&#39;); /* iOS 4.1- */}</code><br><a href="https://www.w3cplus.com/content/css3-font-face">字体</a> (字体包下载地址)<br><a href="www.dafont.com">字体</a> (字体包下载地址)</p><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>border-image方法–边框应用背景<br>border-image: url(xxx.png)  number<br>               stretch 很好理解就是拉伸，有多长拉多长。有多远“滚”多远<br>               repeat (和4角上 同等大小图片进行平铺  当边框中间区域长度不是4角图片大小的整数倍时 会被切割)<br>               铺满(round)(4角上的图片 进行拉伸平铺  不会被切割)<br>（共三个参数）<br>number 为截取指定图片四周的宽度作为border的背景填充部分(截取图可按border-width 大小伸缩), number为一个数字时是复合写法。最后一个属性为border-image的展示策略</p><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p>背景图片起始位置background-origin<br>语法：<br>background-origin ： border-box | padding-box | content-box;<br>参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>裁剪背景图片background-clip<br>语法：<br>background-clip ： border-box | padding-box | content-box | no-clip<br>参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。background-clip默认值为border-box。<br>text : background-clip : text ;<br>从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果。这个很炫哦~~<br>注意：webkit独有属性，且必须配合text-fill-color属性<br><code>-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-fill-color:-webkit-background-clip;-webkit-background-clip: text;-webkit-text-fill-color:transparent;</code></p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>背景图片尺寸background-size<br>设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。<br>语法：<br>background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain<br>取值说明：</p><ol><li>auto：默认值，不改变背景图片的原始高度和宽度；</li><li>&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；</li><li>&lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；</li><li>cover：用一张图片铺满整个背景，如果比例不符，则截断图片</li><li>contain：尽量让背景内，存在一整张图片</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; CSS3新增加的功能和属性方法--之选择器：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;学习css必须要精通的基础哦~CSS3—选择器详解，一起来看看吧~&lt;br&gt;
    
    </summary>
    
      <category term="必备知识" scheme="https://dexinser.github.io/categories/%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="CSS3" scheme="https://dexinser.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>CSS3动画的使用方法</title>
    <link href="https://dexinser.github.io/2017/12/CSS3-%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>https://dexinser.github.io/2017/12/CSS3-动画的使用.html</id>
    <published>2017-12-05T16:00:00.000Z</published>
    <updated>2022-11-14T16:32:59.894Z</updated>
    
    <content type="html"><![CDATA[<p><strong> CSS3动画的使用方法：</strong> <Excerpt in index | 首页摘要></p><p>CSS3动画的使用方法详解，一起来看看吧~<br><a id="more"></a></p><The rest of contents | 余下全文><h1 id="CSS3动画的使用方法"><a href="#CSS3动画的使用方法" class="headerlink" title="CSS3动画的使用方法"></a>CSS3动画的使用方法</h1><h2 id="形状变换-—-高级动画基础"><a href="#形状变换-—-高级动画基础" class="headerlink" title="形状变换  —   高级动画基础"></a>形状变换  —   高级动画基础</h2><h3 id="transform-–-可以实现元素的形状、角度、位置等的变化。"><a href="#transform-–-可以实现元素的形状、角度、位置等的变化。" class="headerlink" title="transform – 可以实现元素的形状、角度、位置等的变化。"></a>transform – 可以实现元素的形状、角度、位置等的变化。</h3><p>他的值有很多种：</p><h4 id="旋转："><a href="#旋转：" class="headerlink" title="旋转："></a>旋转：</h4><p>rotate(); 以x/y/z为轴进行旋转，默认为z<br>rotatex(), rotatey(), rotatez(), rotate3d(x, y, z, angle) x, y, z —&gt;</p><h4 id="缩放："><a href="#缩放：" class="headerlink" title="缩放："></a>缩放：</h4><p>scale(); 以x/y为轴进行缩放<br>scale(x, y) 接受两个值，如果第二参数未提供，则第二个参数使用第一个参数的值<br>scalex(),scaley() 值是数字表示倍数，不加任何单位<br>scalez()<br>scale3d()  scale3d(sx,sy,sz)</p><h4 id="扭曲："><a href="#扭曲：" class="headerlink" title="扭曲："></a>扭曲：</h4><p>skew(); 对元素进行倾斜扭曲<br>skew(x, y);接受两个值，第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0<br>skewx(), skewy()</p><h4 id="平移："><a href="#平移：" class="headerlink" title="平移："></a>平移：</h4><p>translate(); 可以移动距离,相对于自身位置。<br>translate(x, [y])<br>translatex(),translatey(),translatez(),translate3d(x, y, z)  正规的写法是XYZ都应该是大写的。括号里面的值可以是像素(px, %)  当不知道元素自身的宽高是应该用这个百分比法来进行居中处理(-50%,-50%);</p><h4 id="transform-origin-变换原点"><a href="#transform-origin-变换原点" class="headerlink" title="transform-origin 变换原点"></a>transform-origin 变换原点</h4><p>任何一个元素都有一个中心点，<br>默认情况下，其中心点是居于元素x轴和y轴的50%处。配合缩放的方法来使用，根据中心点的位置进行缩放。</p><h4 id="transition-过渡动画"><a href="#transition-过渡动画" class="headerlink" title="transition  过渡动画"></a>transition  过渡动画</h4><p>transition  属性是css3的一个复合属性，主要包括一下几个子属性<br>transition-property:指定过渡或动态模拟的css属性<br>transition-duration:指定过渡所需要的时间<br>transition-timing-function:指定过渡函数<br>transition-delay:指定开始出现的延迟时间</p><p>transition  过渡动画可以参与过渡的属性</p><h4 id="animation-–-动画铺垫"><a href="#animation-–-动画铺垫" class="headerlink" title="animation – 动画铺垫"></a>animation – 动画铺垫</h4><p>动画关键帧<br>@keyframes </p><p>animation 动画会按照keyframes 关键帧里面指定的帧状态而过渡执行。<br>0% - 100% 代表动画的时间过渡<br>@keyframes demoMove{<br>0%{ background-color:red;}<br>10%{ background-color:green;}<br>20%{ background-color:white;}<br>50%{ width:200px;}<br>100%{ height:200px;}</p><p>animation 属性为css3的复合属性，主要包括以下子属性<br>animation-name:  此属性为执行动画的 keyframe 名<br>animation-duration:此属性为动画执行的时间<br>animation-timing-function:指定过渡函数速率<br>animation-delay: 执行延迟时间<br>animation-direction: normal/reverse/alternate/alternate-reverse;<br>animation-iteration-count:infinite/number;<br>animation-fill-mode:forwards/backwards/both/none;</p><p>animation-iteration-count:<br>            属性主要用来定义动画的播放次数。<br>            n 播放次数<br>            infinite 无限次<br>       animation-direction:<br>            属性主要用来设置动画播放方向<br>            normal  默认值。动画按正常播放。    测试 »<br>            reverse 动画反向播放。 测试 »<br>            alternate   动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。    测试 »<br>            alternate-reverse   动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。    测试 »</p><p>animation-play-state:<br>            属性主要用来控制元素动画的播放状态。<br>            running 播放<br>            paused  暂停<br>       animation-fill-mode:<br>            属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：<br>            none:<br>                默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时，动画会反转到初始帧处</p><pre><code>forwards:    表示动画在结束后继续应用最后的关键帧的位置backwards:    会在向元素应用动画样式时迅速应用动画的初始帧both:    元素动画同时具有forwards和backwards效果</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; CSS3动画的使用方法：&lt;/strong&gt; &lt;Excerpt in index | 首页摘要&gt;&lt;/p&gt;
&lt;p&gt;CSS3动画的使用方法详解，一起来看看吧~&lt;br&gt;
    
    </summary>
    
      <category term="必备知识" scheme="https://dexinser.github.io/categories/%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="CSS3" scheme="https://dexinser.github.io/tags/CSS3/"/>
    
  </entry>
  
</feed>
